From bauermann at kolabnow.com  Fri Jul  2 17:11:00 2021
From: bauermann at kolabnow.com (Thiago Jung Bauermann)
Date: Fri, 02 Jul 2021 12:11:00 -0300
Subject: [Dev-luatex] bug#48064: texlive-* packages fail to build
 non-deterministically
In-Reply-To: <CAG5iGsDpnaRLqU2CvA_sNSJcdTHX44YdiJfEoY1GAc5Qs1XXFw@mail.gmail.com>
References: <871rav68km.fsf@inria.fr> <877dicr9k7.fsf@gnu.org>
 <CAG5iGsDpnaRLqU2CvA_sNSJcdTHX44YdiJfEoY1GAc5Qs1XXFw@mail.gmail.com>
Message-ID: <2640745.LZQS8YVrSi@popigai>

Em quarta-feira, 30 de junho de 2021, Ã s 08:53:41 -03, luigi scarso escreveu:
> On Wed, Jun 30, 2021 at 8:20 AM Ludovic CourtÃ¨s <ludo at gnu.org> wrote:
> > Hi,
> > 
> > Ludovic CourtÃ¨s <ludo at gnu.org> skribis:
> > > While investigating luatex crashes in the TeX Live 2020 package of
> > > GNU GuixÂ¹, we identified the following heap corruption reported by
> > 
> > > Valgrind (this is on GNU/Linux, with glibc 2.33):
> > This time with debug info for luatex:
> Thank you for the report, I will check asap.

Thanks! I was able to run Valgrind on LuaTeX 1.13.0, which is the latest 
one in TeX Live 2021.

The invalid reads and writes donât happen on every run. I had to re-run the 
command 3 or 4 times until I got the result below (which matches our 
experience with the build failures in Guix packages)

-- 
Thanks,
Thiago


$ valgrind --extra-debuginfo-path=/gnu/store/rkhx3pj1qi7fx6pi9p2cg2sb9zn59qmg-profile/lib/debug luatex amsclass.ins
==239904== Memcheck, a memory error detector
==239904== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==239904== Using Valgrind-3.17.0 and LibVEX; rerun with -h for copyright info
==239904== Command: luatex amsclass.ins
==239904==
This is LuaTeX, Version 1.13.0 (TeX Live 2021)
 restricted system commands enabled.
==239904== Invalid write of size 8
==239904==    at 0x4860691: lua_pushlstring (lapi.c:483)
==239904==    by 0x56A963: load_hyphenation (texlang.c:306)
==239904==    by 0x56D0CC: undump_one_language (texlang.c:1277)
==239904==    by 0x56D0CC: undump_language_data (texlang.c:1290)
==239904==    by 0x4E0D7F: load_fmt_file (dumpdata.c:520)
==239904==    by 0x4F03DD: main_body (mainbody.c:540)
==239904==    by 0x45118D: main (luatex.c:609)
==239904==  Address 0x894aa30 is 0 bytes after a block of size 1,184 alloc'd
==239904==    at 0x484242B: realloc (in /gnu/store/a4xjjppiw7x0vgd2jimmzssj9i22jf5f-valgrind-3.17.0/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==239904==    by 0x466BCD: my_luaalloc (luastuff.c:115)
==239904==    by 0x48719C2: luaM_realloc_ (lmem.c:86)
==239904==    by 0x486A122: luaD_reallocstack (ldo.c:182)
==239904==    by 0x486CC17: traversethread (lgc.c:549)
==239904==    by 0x486CC17: propagatemark (lgc.c:588)
==239904==    by 0x486CFFF: singlestep (lgc.c:1057)
==239904==    by 0x486D8BB: luaC_step (lgc.c:1137)
==239904==    by 0x48606BB: lua_pushlstring (lapi.c:485)
==239904==    by 0x56A963: load_hyphenation (texlang.c:306)
==239904==    by 0x56D0CC: undump_one_language (texlang.c:1277)
==239904==    by 0x56D0CC: undump_language_data (texlang.c:1290)
==239904==    by 0x4E0D7F: load_fmt_file (dumpdata.c:520)
==239904==    by 0x4F03DD: main_body (mainbody.c:540)
==239904==
==239904== Invalid write of size 4
==239904==    at 0x48606A2: lua_pushlstring (lapi.c:483)
==239904==    by 0x56A963: load_hyphenation (texlang.c:306)
==239904==    by 0x56D0CC: undump_one_language (texlang.c:1277)
==239904==    by 0x56D0CC: undump_language_data (texlang.c:1290)
==239904==    by 0x4E0D7F: load_fmt_file (dumpdata.c:520)
==239904==    by 0x4F03DD: main_body (mainbody.c:540)
==239904==    by 0x45118D: main (luatex.c:609)
==239904==  Address 0x894aa38 is 8 bytes after a block of size 1,184 alloc'd
==239904==    at 0x484242B: realloc (in /gnu/store/a4xjjppiw7x0vgd2jimmzssj9i22jf5f-valgrind-3.17.0/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==239904==    by 0x466BCD: my_luaalloc (luastuff.c:115)
==239904==    by 0x48719C2: luaM_realloc_ (lmem.c:86)
==239904==    by 0x486A122: luaD_reallocstack (ldo.c:182)
==239904==    by 0x486CC17: traversethread (lgc.c:549)
==239904==    by 0x486CC17: propagatemark (lgc.c:588)
==239904==    by 0x486CFFF: singlestep (lgc.c:1057)
==239904==    by 0x486D8BB: luaC_step (lgc.c:1137)
==239904==    by 0x48606BB: lua_pushlstring (lapi.c:485)
==239904==    by 0x56A963: load_hyphenation (texlang.c:306)
==239904==    by 0x56D0CC: undump_one_language (texlang.c:1277)
==239904==    by 0x56D0CC: undump_language_data (texlang.c:1290)
==239904==    by 0x4E0D7F: load_fmt_file (dumpdata.c:520)
==239904==    by 0x4F03DD: main_body (mainbody.c:540)
==239904==
==239904== Invalid read of size 16
==239904==    at 0x4861269: lua_rawset (lapi.c:809)
==239904==    by 0x56A974: load_hyphenation (texlang.c:307)
==239904==    by 0x56D0CC: undump_one_language (texlang.c:1277)
==239904==    by 0x56D0CC: undump_language_data (texlang.c:1290)
==239904==    by 0x4E0D7F: load_fmt_file (dumpdata.c:520)
==239904==    by 0x4F03DD: main_body (mainbody.c:540)
==239904==    by 0x45118D: main (luatex.c:609)
==239904==  Address 0x894aa30 is 0 bytes after a block of size 1,184 alloc'd
==239904==    at 0x484242B: realloc (in /gnu/store/a4xjjppiw7x0vgd2jimmzssj9i22jf5f-valgrind-3.17.0/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==239904==    by 0x466BCD: my_luaalloc (luastuff.c:115)
==239904==    by 0x48719C2: luaM_realloc_ (lmem.c:86)
==239904==    by 0x486A122: luaD_reallocstack (ldo.c:182)
==239904==    by 0x486CC17: traversethread (lgc.c:549)
==239904==    by 0x486CC17: propagatemark (lgc.c:588)
==239904==    by 0x486CFFF: singlestep (lgc.c:1057)
==239904==    by 0x486D8BB: luaC_step (lgc.c:1137)
==239904==    by 0x48606BB: lua_pushlstring (lapi.c:485)
==239904==    by 0x56A963: load_hyphenation (texlang.c:306)
==239904==    by 0x56D0CC: undump_one_language (texlang.c:1277)
==239904==    by 0x56D0CC: undump_language_data (texlang.c:1290)
==239904==    by 0x4E0D7F: load_fmt_file (dumpdata.c:520)
==239904==    by 0x4F03DD: main_body (mainbody.c:540)
==239904==
==239904== Invalid read of size 1
==239904==    at 0x486127D: lua_rawset (lapi.c:811)
==239904==    by 0x56A974: load_hyphenation (texlang.c:307)
==239904==    by 0x56D0CC: undump_one_language (texlang.c:1277)
==239904==    by 0x56D0CC: undump_language_data (texlang.c:1290)
==239904==    by 0x4E0D7F: load_fmt_file (dumpdata.c:520)
==239904==    by 0x4F03DD: main_body (mainbody.c:540)
==239904==    by 0x45118D: main (luatex.c:609)
==239904==  Address 0x894aa38 is 8 bytes after a block of size 1,184 alloc'd
==239904==    at 0x484242B: realloc (in /gnu/store/a4xjjppiw7x0vgd2jimmzssj9i22jf5f-valgrind-3.17.0/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==239904==    by 0x466BCD: my_luaalloc (luastuff.c:115)
==239904==    by 0x48719C2: luaM_realloc_ (lmem.c:86)
==239904==    by 0x486A122: luaD_reallocstack (ldo.c:182)
==239904==    by 0x486CC17: traversethread (lgc.c:549)
==239904==    by 0x486CC17: propagatemark (lgc.c:588)
==239904==    by 0x486CFFF: singlestep (lgc.c:1057)
==239904==    by 0x486D8BB: luaC_step (lgc.c:1137)
==239904==    by 0x48606BB: lua_pushlstring (lapi.c:485)
==239904==    by 0x56A963: load_hyphenation (texlang.c:306)
==239904==    by 0x56D0CC: undump_one_language (texlang.c:1277)
==239904==    by 0x56D0CC: undump_language_data (texlang.c:1290)
==239904==    by 0x4E0D7F: load_fmt_file (dumpdata.c:520)
==239904==    by 0x4F03DD: main_body (mainbody.c:540)
==239904==
==239904== Invalid write of size 8
==239904==    at 0x485F068: auxgetstr (lapi.c:596)
==239904==    by 0x463955: check_texconfig_init (luainit.c:1198)
==239904==    by 0x4F0507: main_body (mainbody.c:565)
==239904==    by 0x45118D: main (luatex.c:609)
==239904==  Address 0x894aa30 is 0 bytes after a block of size 1,184 alloc'd
==239904==    at 0x484242B: realloc (in /gnu/store/a4xjjppiw7x0vgd2jimmzssj9i22jf5f-valgrind-3.17.0/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==239904==    by 0x466BCD: my_luaalloc (luastuff.c:115)
==239904==    by 0x48719C2: luaM_realloc_ (lmem.c:86)
==239904==    by 0x486A122: luaD_reallocstack (ldo.c:182)
==239904==    by 0x486CC17: traversethread (lgc.c:549)
==239904==    by 0x486CC17: propagatemark (lgc.c:588)
==239904==    by 0x486CFFF: singlestep (lgc.c:1057)
==239904==    by 0x486D8BB: luaC_step (lgc.c:1137)
==239904==    by 0x48606BB: lua_pushlstring (lapi.c:485)
==239904==    by 0x56A963: load_hyphenation (texlang.c:306)
==239904==    by 0x56D0CC: undump_one_language (texlang.c:1277)
==239904==    by 0x56D0CC: undump_language_data (texlang.c:1290)
==239904==    by 0x4E0D7F: load_fmt_file (dumpdata.c:520)
==239904==    by 0x4F03DD: main_body (mainbody.c:540)
==239904==
==239904== Invalid write of size 4
==239904==    at 0x485F07A: auxgetstr (lapi.c:596)
==239904==    by 0x463955: check_texconfig_init (luainit.c:1198)
==239904==    by 0x4F0507: main_body (mainbody.c:565)
==239904==    by 0x45118D: main (luatex.c:609)
==239904==  Address 0x894aa38 is 8 bytes after a block of size 1,184 alloc'd
==239904==    at 0x484242B: realloc (in /gnu/store/a4xjjppiw7x0vgd2jimmzssj9i22jf5f-valgrind-3.17.0/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==239904==    by 0x466BCD: my_luaalloc (luastuff.c:115)
==239904==    by 0x48719C2: luaM_realloc_ (lmem.c:86)
==239904==    by 0x486A122: luaD_reallocstack (ldo.c:182)
==239904==    by 0x486CC17: traversethread (lgc.c:549)
==239904==    by 0x486CC17: propagatemark (lgc.c:588)
==239904==    by 0x486CFFF: singlestep (lgc.c:1057)
==239904==    by 0x486D8BB: luaC_step (lgc.c:1137)
==239904==    by 0x48606BB: lua_pushlstring (lapi.c:485)
==239904==    by 0x56A963: load_hyphenation (texlang.c:306)
==239904==    by 0x56D0CC: undump_one_language (texlang.c:1277)
==239904==    by 0x56D0CC: undump_language_data (texlang.c:1290)
==239904==    by 0x4E0D7F: load_fmt_file (dumpdata.c:520)
==239904==    by 0x4F03DD: main_body (mainbody.c:540)
==239904==
==239904== Invalid write of size 4
==239904==    at 0x4880608: luaV_finishget (lvm.c:176)
==239904==    by 0x485F089: auxgetstr (lapi.c:598)
==239904==    by 0x463955: check_texconfig_init (luainit.c:1198)
==239904==    by 0x4F0507: main_body (mainbody.c:565)
==239904==    by 0x45118D: main (luatex.c:609)
==239904==  Address 0x894aa38 is 8 bytes after a block of size 1,184 alloc'd
==239904==    at 0x484242B: realloc (in /gnu/store/a4xjjppiw7x0vgd2jimmzssj9i22jf5f-valgrind-3.17.0/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==239904==    by 0x466BCD: my_luaalloc (luastuff.c:115)
==239904==    by 0x48719C2: luaM_realloc_ (lmem.c:86)
==239904==    by 0x486A122: luaD_reallocstack (ldo.c:182)
==239904==    by 0x486CC17: traversethread (lgc.c:549)
==239904==    by 0x486CC17: propagatemark (lgc.c:588)
==239904==    by 0x486CFFF: singlestep (lgc.c:1057)
==239904==    by 0x486D8BB: luaC_step (lgc.c:1137)
==239904==    by 0x48606BB: lua_pushlstring (lapi.c:485)
==239904==    by 0x56A963: load_hyphenation (texlang.c:306)
==239904==    by 0x56D0CC: undump_one_language (texlang.c:1277)
==239904==    by 0x56D0CC: undump_language_data (texlang.c:1290)
==239904==    by 0x4E0D7F: load_fmt_file (dumpdata.c:520)
==239904==    by 0x4F03DD: main_body (mainbody.c:540)
==239904==
==239904== Invalid read of size 4
==239904==    at 0x485F092: auxgetstr (lapi.c:601)
==239904==    by 0x463955: check_texconfig_init (luainit.c:1198)
==239904==    by 0x4F0507: main_body (mainbody.c:565)
==239904==    by 0x45118D: main (luatex.c:609)
==239904==  Address 0x894aa38 is 8 bytes after a block of size 1,184 alloc'd
==239904==    at 0x484242B: realloc (in /gnu/store/a4xjjppiw7x0vgd2jimmzssj9i22jf5f-valgrind-3.17.0/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==239904==    by 0x466BCD: my_luaalloc (luastuff.c:115)
==239904==    by 0x48719C2: luaM_realloc_ (lmem.c:86)
==239904==    by 0x486A122: luaD_reallocstack (ldo.c:182)
==239904==    by 0x486CC17: traversethread (lgc.c:549)
==239904==    by 0x486CC17: propagatemark (lgc.c:588)
==239904==    by 0x486CFFF: singlestep (lgc.c:1057)
==239904==    by 0x486D8BB: luaC_step (lgc.c:1137)
==239904==    by 0x48606BB: lua_pushlstring (lapi.c:485)
==239904==    by 0x56A963: load_hyphenation (texlang.c:306)
==239904==    by 0x56D0CC: undump_one_language (texlang.c:1277)
==239904==    by 0x56D0CC: undump_language_data (texlang.c:1290)
==239904==    by 0x4E0D7F: load_fmt_file (dumpdata.c:520)
==239904==    by 0x4F03DD: main_body (mainbody.c:540)
==239904==
==239904== Invalid read of size 4
==239904==    at 0x485F6D9: lua_type (lapi.c:253)
==239904==    by 0x463966: check_texconfig_init (luainit.c:1199)
==239904==    by 0x4F0507: main_body (mainbody.c:565)
==239904==    by 0x45118D: main (luatex.c:609)
==239904==  Address 0x894aa38 is 8 bytes after a block of size 1,184 alloc'd
==239904==    at 0x484242B: realloc (in /gnu/store/a4xjjppiw7x0vgd2jimmzssj9i22jf5f-valgrind-3.17.0/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==239904==    by 0x466BCD: my_luaalloc (luastuff.c:115)
==239904==    by 0x48719C2: luaM_realloc_ (lmem.c:86)
==239904==    by 0x486A122: luaD_reallocstack (ldo.c:182)
==239904==    by 0x486CC17: traversethread (lgc.c:549)
==239904==    by 0x486CC17: propagatemark (lgc.c:588)
==239904==    by 0x486CFFF: singlestep (lgc.c:1057)
==239904==    by 0x486D8BB: luaC_step (lgc.c:1137)
==239904==    by 0x48606BB: lua_pushlstring (lapi.c:485)
==239904==    by 0x56A963: load_hyphenation (texlang.c:306)
==239904==    by 0x56D0CC: undump_one_language (texlang.c:1277)
==239904==    by 0x56D0CC: undump_language_data (texlang.c:1290)
==239904==    by 0x4E0D7F: load_fmt_file (dumpdata.c:520)
==239904==    by 0x4F03DD: main_body (mainbody.c:540)
==239904==
(./amsclass.ins (/gnu/store/rkhx3pj1qi7fx6pi9p2cg2sb9zn59qmg-profile/share/texmf-dist/tex/latex/base/docstrip.tex==239904== Conditional jump or move depends on uninitialised value(s)
==239904==    at 0x4647BD: tprint (printing.c:484)
==239904==    by 0x4E5E6B: write_out (extensions.c:583)
==239904==    by 0x4E62EA: wrapup_leader (extensions.c:1324)
==239904==    by 0x4E62EA: do_extension (extensions.c:423)
==239904==    by 0x4F4860: main_control (maincontrol.c:1030)
==239904==    by 0x4F0537: main_body (mainbody.c:577)
==239904==    by 0x45118D: main (luatex.c:609)
==239904==

==239904== Conditional jump or move depends on uninitialised value(s)
==239904==    at 0x4647BD: tprint (printing.c:484)
==239904==    by 0x4E5DED: write_out (extensions.c:585)
==239904==    by 0x4E62EA: wrapup_leader (extensions.c:1324)
==239904==    by 0x4E62EA: do_extension (extensions.c:423)
==239904==    by 0x4F4860: main_control (maincontrol.c:1030)
==239904==    by 0x4F0537: main_body (mainbody.c:577)
==239904==    by 0x45118D: main (luatex.c:609)
==239904==
Utility: `docstrip' v2.6a <2020-07-07>
English documentation    <2020-07-11>
==239904== Conditional jump or move depends on uninitialised value(s)
==239904==    at 0x464523: tprint (printing.c:512)
==239904==    by 0x4E5DED: write_out (extensions.c:585)
==239904==    by 0x4E62EA: wrapup_leader (extensions.c:1324)
==239904==    by 0x4E62EA: do_extension (extensions.c:423)
==239904==    by 0x4F4860: main_control (maincontrol.c:1030)
==239904==    by 0x4F0537: main_body (mainbody.c:577)
==239904==    by 0x45118D: main (luatex.c:609)
==239904==

**********************************************************
* This program converts documented macro-files into fast *
* loadable files by stripping off (nearly) all comments! *
**********************************************************

********************************************************
* No Configuration file found, using default settings. *
********************************************************

)

Generating file(s) amsthm.sty amsart.cls amsbook.cls amsproc.cls

Processing file amsclass.dtx (amsthm) -> amsthm.sty
                             (amsart,classes) -> amsart.cls
                             (amsbook,classes) -> amsbook.cls
                             (amsproc,classes) -> amsproc.cls
File amsclass.dtx ended by \endinput.
Lines  processed: 5197
Comments removed: 2926
Comments  passed: 21
Codelines passed: 2062

)
warning  (pdf backend): no pages of output.
Transcript written on amsclass.log.
==239904== Invalid write of size 8
==239904==    at 0x486C013: GCTM (lgc.c:819)
==239904==    by 0x486D779: callallpendingfinalizers (lgc.c:862)
==239904==    by 0x486D779: luaC_freeallobjects (lgc.c:971)
==239904==    by 0x4877A0B: close_state (lstate.c:245)
==239904==    by 0x4E33A5: do_final_end (errors.c:257)
==239904==    by 0x45118D: main (luatex.c:609)
==239904==  Address 0x894aa40 is 16 bytes after a block of size 1,184 alloc'd
==239904==    at 0x484242B: realloc (in /gnu/store/a4xjjppiw7x0vgd2jimmzssj9i22jf5f-valgrind-3.17.0/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==239904==    by 0x466BCD: my_luaalloc (luastuff.c:115)
==239904==    by 0x48719C2: luaM_realloc_ (lmem.c:86)
==239904==    by 0x486A122: luaD_reallocstack (ldo.c:182)
==239904==    by 0x486CC17: traversethread (lgc.c:549)
==239904==    by 0x486CC17: propagatemark (lgc.c:588)
==239904==    by 0x486CFFF: singlestep (lgc.c:1057)
==239904==    by 0x486D8BB: luaC_step (lgc.c:1137)
==239904==    by 0x48606BB: lua_pushlstring (lapi.c:485)
==239904==    by 0x56A963: load_hyphenation (texlang.c:306)
==239904==    by 0x56D0CC: undump_one_language (texlang.c:1277)
==239904==    by 0x56D0CC: undump_language_data (texlang.c:1290)
==239904==    by 0x4E0D7F: load_fmt_file (dumpdata.c:520)
==239904==    by 0x4F03DD: main_body (mainbody.c:540)
==239904==

valgrind: m_mallocfree.c:303 (get_bszB_as_is): Assertion 'bszB_lo == bszB_hi' failed.
valgrind: Heap block lo/hi size mismatch: lo = 1248, hi = 102.
This is probably caused by your program erroneously writing past the
end of a heap block and corrupting heap metadata.  If you fix any
invalid writes reported by Memcheck, this assertion failure will
probably go away.  Please try that before reporting this as a bug.


host stacktrace:
==239904==    at 0x5803F050: ??? (in /gnu/store/a4xjjppiw7x0vgd2jimmzssj9i22jf5f-valgrind-3.17.0/libexec/valgrind/memcheck-amd64-linux)
==239904==    by 0x5803F157: ??? (in /gnu/store/a4xjjppiw7x0vgd2jimmzssj9i22jf5f-valgrind-3.17.0/libexec/valgrind/memcheck-amd64-linux)
==239904==    by 0x5803F2DE: ??? (in /gnu/store/a4xjjppiw7x0vgd2jimmzssj9i22jf5f-valgrind-3.17.0/libexec/valgrind/memcheck-amd64-linux)
==239904==    by 0x58048742: ??? (in /gnu/store/a4xjjppiw7x0vgd2jimmzssj9i22jf5f-valgrind-3.17.0/libexec/valgrind/memcheck-amd64-linux)
==239904==    by 0x58037DCB: ??? (in /gnu/store/a4xjjppiw7x0vgd2jimmzssj9i22jf5f-valgrind-3.17.0/libexec/valgrind/memcheck-amd64-linux)
==239904==    by 0x58036637: ??? (in /gnu/store/a4xjjppiw7x0vgd2jimmzssj9i22jf5f-valgrind-3.17.0/libexec/valgrind/memcheck-amd64-linux)
==239904==    by 0x5803AAB2: ??? (in /gnu/store/a4xjjppiw7x0vgd2jimmzssj9i22jf5f-valgrind-3.17.0/libexec/valgrind/memcheck-amd64-linux)
==239904==    by 0x58035988: ??? (in /gnu/store/a4xjjppiw7x0vgd2jimmzssj9i22jf5f-valgrind-3.17.0/libexec/valgrind/memcheck-amd64-linux)
==239904==    by 0x100417A3ED: ???
==239904==    by 0x1002CB9F2F: ???
==239904==    by 0xBF0E: ???

sched status:
  running_tid=1

Thread 1: status = VgTs_Runnable (lwpid 239904)
==239904==    at 0x486C01B: GCTM (lgc.c:820)
==239904==    by 0x486D779: callallpendingfinalizers (lgc.c:862)
==239904==    by 0x486D779: luaC_freeallobjects (lgc.c:971)
==239904==    by 0x4877A0B: close_state (lstate.c:245)
==239904==    by 0x4E33A5: do_final_end (errors.c:257)
==239904==    by 0x45118D: main (luatex.c:609)
client stack range: [0x1FFEFB0000 0x1FFF000FFF] client SP: 0x1FFF000130
valgrind stack range: [0x1002BBA000 0x1002CB9FFF] top usage: 9624 of 1048576


Note: see also the FAQ in the source distribution.
It contains workarounds to several common problems.
In particular, if Valgrind aborted or crashed after
identifying problems in your program, there's a good chance
that fixing those problems will prevent Valgrind aborting or
crashing, especially if it happened in m_mallocfree.c.

If that doesn't help, please report this bug to: www.valgrind.org

In the bug report, send all the above text, the valgrind
version, and what OS and version you are using.  Thanks.

$ echo $?
1




From lahcim8 at gmail.com  Tue Jul 20 18:01:27 2021
From: lahcim8 at gmail.com (=?utf-8?q?Michal_Vlas=C3=A1k?=)
Date: Tue, 20 Jul 2021 18:01:27 +0200
Subject: [Dev-luatex] Dump sharing - redundant copying/allocations
Message-ID: <CCY3D8XA1G6U.294B58I2IDHF0@phobos>

Hello,

when NO_DUMP_SHARE is not defined and the system is Little endian, then
for the possibility of sharing format files between architectures all
dumped multi-byte valules are byte swapped by the function "swap_items"
in "tex/texfileio.c".

The origin of the function is in Web2C's "texmfmp.c" and it seems that
it was added to LuaTeX in the version 1.08 when the source was converted
from CWeb (or am I reading the history wrong?).

However, there are two differences between Web2C's and LuaTeX's
"swap_items":

1) LuaTeX also supports 12 byte values.

and more importantly:

2) LuaTeX essentially does this:
   - allocate temporary array
   - copy input to temporary array
   - [common code with web2c]
   - copy temporary array back to input to serve as output
   - free temporary array

This all seems redundant and causes many small allocations (~350K
allocations for a ~800K format file), because most allocations are of
only 4 bytes.

Curiously the gcc -O2 optimizer doesn't catch this even though it is a
static function (and changing xmalloc/xfree to the "intrinsic"
malloc/free doesn't help it). Maybe the possible unsigned int overflow
prevents the optimization? Or am I missing some side effect/purpose of
the copying/allocating?

See my proposal below.

(Note that in the LuaTeX repository --disable-dump-share is the default,
while it isn't in TeX Live, I think.)


Michal VlasÃ¡k

--- a/tex/texfileio.c
+++ b/tex/texfileio.c
@@ -1125,13 +1125,9 @@ static gzFile gz_fmtfile = NULL;
 
 */
 
-static void swap_items(char *pp, int nitems, int size)
+static void swap_items(char *p, int nitems, int size)
 {
     char temp;
-    unsigned total = (unsigned) (nitems * size);
-    char *q = xmalloc(total);
-    char *p = q;
-    memcpy(p,pp,total);
     /*tex
 
         Since `size' does not change, we can write a while loop for each case,
@@ -1201,8 +1197,6 @@ static void swap_items(char *pp, int nitems, int size)
         default:
             FATAL1("Can't swap a %d-byte item for (un)dumping", size);
     }
-    memcpy(pp,q,total);
-    xfree(q);
 }
 #endif
 

From taco at bittext.nl  Tue Jul 20 19:56:12 2021
From: taco at bittext.nl (Taco Hoekwater)
Date: Tue, 20 Jul 2021 19:56:12 +0200
Subject: [Dev-luatex] Dump sharing - redundant copying/allocations
In-Reply-To: <CCY3D8XA1G6U.294B58I2IDHF0@phobos>
References: <CCY3D8XA1G6U.294B58I2IDHF0@phobos>
Message-ID: <9C6197A5-F7B5-4217-879F-BB566F583CAF@bittext.nl>

Hi,

> On 20 Jul 2021, at 18:01, Michal VlasÃ¡k <lahcim8 at gmail.com> wrote:
> 
> Hello,
> 
> when NO_DUMP_SHARE is not defined and the system is Little endian, then
> for the possibility of sharing format files between architectures all
> dumped multi-byte valules are byte swapped by the function "swap_items"
> in "tex/texfileio.c".
> 
> The origin of the function is in Web2C's "texmfmp.c" and it seems that
> it was added to LuaTeX in the version 1.08 when the source was converted
> from CWeb (or am I reading the history wrong?).

That code has been around since 2010 (luatex 0.60-ish). I canât remember
exactly why I did that odd copying to a temp array, but I do remember that 
that particular function was quite problematic w.r.t. endianness and 
(cross)compiler issues (read: bugs, as in âinternal compiler error").

Best wishes,
Taco

â 
Taco Hoekwater              E: taco at bittext.nl
genderfluid (all pronouns)




From lahcim8 at gmail.com  Tue Jul 20 21:51:14 2021
From: lahcim8 at gmail.com (=?utf-8?q?Michal_Vlas=C3=A1k?=)
Date: Tue, 20 Jul 2021 21:51:14 +0200
Subject: [Dev-luatex] Dump sharing - redundant copying/allocations
In-Reply-To: <9C6197A5-F7B5-4217-879F-BB566F583CAF@bittext.nl>
Message-ID: <CCY896UKBA0H.1V404VHKMDQJC@phobos>

On Tue Jul 20, 2021 at 7:56 PM CEST, Taco Hoekwater wrote:
> Hi,
>
> > On 20 Jul 2021, at 18:01, Michal VlasÃ¡k <lahcim8 at gmail.com> wrote:
> > 
> > Hello,
> > 
> > when NO_DUMP_SHARE is not defined and the system is Little endian, then
> > for the possibility of sharing format files between architectures all
> > dumped multi-byte valules are byte swapped by the function "swap_items"
> > in "tex/texfileio.c".
> > 
> > The origin of the function is in Web2C's "texmfmp.c" and it seems that
> > it was added to LuaTeX in the version 1.08 when the source was converted
> > from CWeb (or am I reading the history wrong?).
>
> That code has been around since 2010 (luatex 0.60-ish). I canât
> remember exactly why I did that odd copying to a temp array, but I do
> remember that that particular function was quite problematic w.r.t.
> endianness and (cross)compiler issues (read: bugs, as in âinternal
> compiler error").

Thank you for your valuable insight Taco. My thinking was skewed because
I read the history incorrectly, thinking it was more of a mistake that
slipped into a big commit.

Anyways despite the number of allocations the performance is probably
fine, since nobody complained, yet. I noticed it by chance while reading
the code.

Best regards,
Michal VlasÃ¡k

From taco at bittext.nl  Wed Jul 21 08:42:49 2021
From: taco at bittext.nl (Taco Hoekwater)
Date: Wed, 21 Jul 2021 08:42:49 +0200
Subject: [Dev-luatex] Dump sharing - redundant copying/allocations
In-Reply-To: <CCY896UKBA0H.1V404VHKMDQJC@phobos>
References: <CCY896UKBA0H.1V404VHKMDQJC@phobos>
Message-ID: <4F910EFD-745A-4BC1-B893-C575D86014E1@bittext.nl>



> On 20 Jul 2021, at 21:51, Michal VlasÃ¡k <lahcim8 at gmail.com> wrote:
> 
> On Tue Jul 20, 2021 at 7:56 PM CEST, Taco Hoekwater wrote:
>> 
>> 
>> That code has been around since 2010 (luatex 0.60-ish). I canât
>> remember exactly why I did that odd copying to a temp array, but I do
>> remember that that particular function was quite problematic w.r.t.
>> endianness and (cross)compiler issues (read: bugs, as in âinternal
>> compiler error").
> 
> Thank you for your valuable insight Taco. My thinking was skewed because
> I read the history incorrectly, thinking it was more of a mistake that
> slipped into a big commit.

It was definitely on purpose at the time. But that doesnât mean 
you are wrong: your patch should probably be applied. More than a decade 
later, the original compiler problems should be fixed
by now (one would hope so!).

There are massive gaps in the luatex part of the svn history of tex-live, 
so I donât think you read the history wrong either, it is just that big 
chunks of luatexâs development have not taken place in the texlive 
repository.

Best wishes,
Taco

â 
Taco Hoekwater              E: taco at bittext.nl
genderfluid (all pronouns)




From j.hagen at xs4all.nl  Wed Jul 21 09:09:29 2021
From: j.hagen at xs4all.nl (Hans Hagen)
Date: Wed, 21 Jul 2021 09:09:29 +0200
Subject: [Dev-luatex] Dump sharing - redundant copying/allocations
In-Reply-To: <CCY896UKBA0H.1V404VHKMDQJC@phobos>
References: <CCY896UKBA0H.1V404VHKMDQJC@phobos>
Message-ID: <bb20c838-f5f3-ffce-b107-5707b4193a54@xs4all.nl>

On 7/20/2021 9:51 PM, Michal VlasÃ¡k wrote:
> On Tue Jul 20, 2021 at 7:56 PM CEST, Taco Hoekwater wrote:
>> Hi,
>>
>>> On 20 Jul 2021, at 18:01, Michal VlasÃ¡k <lahcim8 at gmail.com> wrote:
>>>
>>> Hello,
>>>
>>> when NO_DUMP_SHARE is not defined and the system is Little endian, then
>>> for the possibility of sharing format files between architectures all
>>> dumped multi-byte valules are byte swapped by the function "swap_items"
>>> in "tex/texfileio.c".
>>>
>>> The origin of the function is in Web2C's "texmfmp.c" and it seems that
>>> it was added to LuaTeX in the version 1.08 when the source was converted
>>> from CWeb (or am I reading the history wrong?).
>>
>> That code has been around since 2010 (luatex 0.60-ish). I canât
>> remember exactly why I did that odd copying to a temp array, but I do
>> remember that that particular function was quite problematic w.r.t.
>> endianness and (cross)compiler issues (read: bugs, as in âinternal
>> compiler error").
> 
> Thank you for your valuable insight Taco. My thinking was skewed because
> I read the history incorrectly, thinking it was more of a mistake that
> slipped into a big commit.
> 
> Anyways despite the number of allocations the performance is probably
> fine, since nobody complained, yet. I noticed it by chance while reading
> the code.
just afew remarks:

- dump sharing in luatex makes no sense, also because lua byte code can 
be stored and that is not portable .. for that reason byte swapping was 
removed at some later point in the project

- byte swapping introduces overhead and was happening for the majority 
of users (intel), but the code was/is still there

- we store a format version number in the format so that a format file 
will not be loaded when there is a mismatch (that was added later)

- format gz compression was introduced already early to keep the format 
small and irr that needed some of these copying tweaks

- as you mention, the allocation overhead is small, which is definitely 
true compared to byte swapping and all the decompression calls in 
between (loading the file database at startup probably takes more time, 
and definitely in the early days was quite noticeable, more than format 
loading); the level 3 compression gav ethe best trade-off

- the mentioned 'internal compiler error' mentioned by Taco rings a 
bell, it's a reason why often saving/loading an 'int' goes via a 
variable because compilers would optimize in a way that dumping 
variables (ints) in more complex data structures gave issues

- there are a few more places where using redundant temp vars are used 
because during some operations memory can grow which can makes pointers 
already set invalid, some of those have been sorted out differently in 
the meantime)

- talking of performance, one of the interesting things in the beginning 
of development was that we noticed different (incremental) versions to 
perform differently; for instance when math was opened up the machinery 
became real slow, as if we crossed some boundary, (compilation order of 
specific code modules mattered too); but when i then updated my laptop 
it was fast again, not so much because of fhe faster cpu but because the 
cpu cache was larger; compiler optimization also kind of interfered (at 
that time ideas, experiments and binaries came and went on a daily 
basis, we had quite some fun)

- if performance is of concern, we also noticed (later one when luajit 
enteres the scenary) that the settings for lua hashing matters, and that 
luajit had pretty bad heuristics (tuned for url, we published about 
that) so we used a different hashing there ...

Hans

-----------------------------------------------------------------
                                           Hans Hagen | PRAGMA ADE
               Ridderstraat 27 | 8061 GH Hasselt | The Netherlands
        tel: 038 477 53 69 | www.pragma-ade.nl | www.pragma-pod.nl
-----------------------------------------------------------------

From lahcim8 at gmail.com  Wed Jul 21 13:58:44 2021
From: lahcim8 at gmail.com (=?utf-8?q?Michal_Vlas=C3=A1k?=)
Date: Wed, 21 Jul 2021 13:58:44 +0200
Subject: [Dev-luatex] Dump sharing - redundant copying/allocations
In-Reply-To: <bb20c838-f5f3-ffce-b107-5707b4193a54@xs4all.nl>
Message-ID: <CCYSTYAWOWT1.2AS75U7FLLLHE@phobos>

On Wed Jul 21, 2021 at 9:09 AM CEST, Hans Hagen wrote:
> just afew remarks:
>
> - dump sharing in luatex makes no sense, also because lua byte code
> can be stored and that is not portable .. for that reason byte
> swapping was removed at some later point in the project

Funnily enough, I looked at the code exactly because of this. As it
turns out, in TeX Live after recent problems with format sharing across
32-bit Windows and 64-bit Linux, there is now an effort to ensure the
portability of formats:

https://git.texlive.info/texlive/tree/Master/tlpkg/bin/tl-check-fmtshare

Of course the issue of unportable bytecode came up. As far as I know
three LuaTeX formats store it in format files: ConTeXt (wasn't and
probably won't be checked by the script and users alike), OpTeX and
minim (recent format, not even genereted in TeX Live).

I evaluated the possibility of byte swapping in the Lua (un)dumping, by
introducing a patch in TeX Live, but I don't think it is worth:

 - I personally wouldn't encourage _more_ format sharing between OS's
   and architectures in the future.
 - The types used by Lua (long long, double, int) may not even be
   portable anyways.
 - The "right" approach for portable dumping doesn't fit the current
   architecture.
   (https://commandcenter.blogspot.com/2012/04/byte-order-fallacy.html)

> - byte swapping introduces overhead and was happening for the majority
> of users (intel), but the code was/is still there

I agree that if something the more common Little endian would have been
a better choice.

> - as you mention, the allocation overhead is small, which is
> definitely true compared to byte swapping and all the decompression
> calls in between (loading the file database at startup probably takes
> more time, and definitely in the early days was quite noticeable, more
> than format loading); the level 3 compression gav ethe best trade-off

Interestingly I didn't find any really measurable slowdown from the byte
swapping, possibly because the entire function was turned into a lot of
SIMD instructions. (But to be fair I didn't test with a huge format, and
usually compile LuaTeX with the byte swapping disabled anyways.)

> - the mentioned 'internal compiler error' mentioned by Taco rings a
> bell, it's a reason why often saving/loading an 'int' goes via a
> variable because compilers would optimize in a way that dumping
> variables (ints) in more complex data structures gave issues
>
> - there are a few more places where using redundant temp vars are used
> because during some operations memory can grow which can makes
> pointers already set invalid, some of those have been sorted out
> differently in the meantime)

Very interesting, hopefully the situation improved since.

> - talking of performance, one of the interesting things in the
> beginning of development was that we noticed different (incremental)
> versions to perform differently; for instance when math was opened up
> the machinery became real slow, as if we crossed some boundary,
> (compilation order of specific code modules mattered too); but when i
> then updated my laptop it was fast again, not so much because of fhe
> faster cpu but because the cpu cache was larger; compiler optimization
> also kind of interfered (at that time ideas, experiments and binaries
> came and went on a daily basis, we had quite some fun)
>
> - if performance is of concern, we also noticed (later one when luajit
> enteres the scenary) that the settings for lua hashing matters, and
> that luajit had pretty bad heuristics (tuned for url, we published
> about that) so we used a different hashing there ...

Thank you for your insights and caring about performance!

Michal VlasÃ¡k

From petr at olsak.net  Wed Jul 21 15:13:27 2021
From: petr at olsak.net (Petr Olsak)
Date: Wed, 21 Jul 2021 15:13:27 +0200
Subject: [Dev-luatex] Dump sharing - redundant copying/allocations
In-Reply-To: <CCY3D8XA1G6U.294B58I2IDHF0@phobos>
References: <CCY3D8XA1G6U.294B58I2IDHF0@phobos>
Message-ID: <cd661b24-7703-76fa-827b-6be99909df62@olsak.net>

Hello,

IMHO, the TeX engine can save a flag about Endianity to the format. When 
a TeX engine reads such a format then it can check the current Endianity 
with the saved one and do swapping only if they are different. But this 
idea was'nt implemented: all formats use non-Intel Endianity (by 
decision of develpers), so swapping are processed very often.

Moreover, saving lua bytecode to the format does not support different 
architectures (It was mentioned in this thread too). IMHO, the classical 
message "I am stymied" should be sufficient when a TeX engine reads a 
format generated at different architecture.

Petr Olsak

On 7/20/21 6:01 PM, Michal VlasÃ¡k wrote:
> Hello,
>
> when NO_DUMP_SHARE is not defined and the system is Little endian, then
> for the possibility of sharing format files between architectures all
> dumped multi-byte valules are byte swapped by the function "swap_items"
> in "tex/texfileio.c".
>
> The origin of the function is in Web2C's "texmfmp.c" and it seems that
> it was added to LuaTeX in the version 1.08 when the source was converted
> from CWeb (or am I reading the history wrong?).
>
> However, there are two differences between Web2C's and LuaTeX's
> "swap_items":
>
> 1) LuaTeX also supports 12 byte values.
>
> and more importantly:
>
> 2) LuaTeX essentially does this:
>     - allocate temporary array
>     - copy input to temporary array
>     - [common code with web2c]
>     - copy temporary array back to input to serve as output
>     - free temporary array
>
> This all seems redundant and causes many small allocations (~350K
> allocations for a ~800K format file), because most allocations are of
> only 4 bytes.
>
> Curiously the gcc -O2 optimizer doesn't catch this even though it is a
> static function (and changing xmalloc/xfree to the "intrinsic"
> malloc/free doesn't help it). Maybe the possible unsigned int overflow
> prevents the optimization? Or am I missing some side effect/purpose of
> the copying/allocating?
>
> See my proposal below.
>
> (Note that in the LuaTeX repository --disable-dump-share is the default,
> while it isn't in TeX Live, I think.)
>
>
> Michal VlasÃ¡k
>
> --- a/tex/texfileio.c
> +++ b/tex/texfileio.c
> @@ -1125,13 +1125,9 @@ static gzFile gz_fmtfile = NULL;
>   
>   */
>   
> -static void swap_items(char *pp, int nitems, int size)
> +static void swap_items(char *p, int nitems, int size)
>   {
>       char temp;
> -    unsigned total = (unsigned) (nitems * size);
> -    char *q = xmalloc(total);
> -    char *p = q;
> -    memcpy(p,pp,total);
>       /*tex
>   
>           Since `size' does not change, we can write a while loop for each case,
> @@ -1201,8 +1197,6 @@ static void swap_items(char *pp, int nitems, int size)
>           default:
>               FATAL1("Can't swap a %d-byte item for (un)dumping", size);
>       }
> -    memcpy(pp,q,total);
> -    xfree(q);
>   }
>   #endif
>   
> _______________________________________________
> dev-luatex mailing list
> dev-luatex at ntg.nl
> https://mailman.ntg.nl/mailman/listinfo/dev-luatex

From j.hagen at xs4all.nl  Wed Jul 21 15:57:00 2021
From: j.hagen at xs4all.nl (Hans Hagen)
Date: Wed, 21 Jul 2021 15:57:00 +0200
Subject: [Dev-luatex] Dump sharing - redundant copying/allocations
In-Reply-To: <CCYSTYAWOWT1.2AS75U7FLLLHE@phobos>
References: <CCYSTYAWOWT1.2AS75U7FLLLHE@phobos>
Message-ID: <34e821ec-9619-9ff3-52a7-6102028e8ade@xs4all.nl>

On 7/21/2021 1:58 PM, Michal VlasÃ¡k wrote:
> On Wed Jul 21, 2021 at 9:09 AM CEST, Hans Hagen wrote:
>> just afew remarks:
>>
>> - dump sharing in luatex makes no sense, also because lua byte code
>> can be stored and that is not portable .. for that reason byte
>> swapping was removed at some later point in the project
> 
> Funnily enough, I looked at the code exactly because of this. As it
> turns out, in TeX Live after recent problems with format sharing across
> 32-bit Windows and 64-bit Linux, there is now an effort to ensure the
> portability of formats:
> 
> https://git.texlive.info/texlive/tree/Master/tlpkg/bin/tl-check-fmtshare
> 
> Of course the issue of unportable bytecode came up. As far as I know
> three LuaTeX formats store it in format files: ConTeXt (wasn't and
> probably won't be checked by the script and users alike), OpTeX and
> minim (recent format, not even genereted in TeX Live).

context always managed its own format generation also because we operate 
on an engine axis too and one never calls context by its format stub

> I evaluated the possibility of byte swapping in the Lua (un)dumping, by
> introducing a patch in TeX Live, but I don't think it is worth:
> 
>   - I personally wouldn't encourage _more_ format sharing between OS's
>     and architectures in the future.
>   - The types used by Lua (long long, double, int) may not even be
>     portable anyways.
>   - The "right" approach for portable dumping doesn't fit the current
>     architecture.
>     (https://commandcenter.blogspot.com/2012/04/byte-order-fallacy.html)

even if one would handle bytes in the lua bytecode, the bytecode itself 
is not portable (and i'm not even sure how luajit stuff fits in because 
luajit is even more platform specific

>> - byte swapping introduces overhead and was happening for the majority
>> of users (intel), but the code was/is still there
> 
> I agree that if something the more common Little endian would have been
> a better choice.

the sharing made sense in the time when one ran tex from a dvd in which 
case all binaries shared the same precooked formats (or on networkshares 
servingb multiple architectures) but afaik running from dvd was dropped 
and hardly anyone runs multiple platforms from one share (those who do 
can probably figure out some trick)

>> - as you mention, the allocation overhead is small, which is
>> definitely true compared to byte swapping and all the decompression
>> calls in between (loading the file database at startup probably takes
>> more time, and definitely in the early days was quite noticeable, more
>> than format loading); the level 3 compression gav ethe best trade-off
> 
> Interestingly I didn't find any really measurable slowdown from the byte
> swapping, possibly because the entire function was turned into a lot of
> SIMD instructions. (But to be fair I didn't test with a huge format, and
> usually compile LuaTeX with the byte swapping disabled anyways.)

it is (or at least) was slower with the native microsoft compiler (win 
32 bins from akira) because that compiler is less agressive in some 
optimzations (we could deduce it plays safe in some areas of memory 
casting especially combined with the gz decompression)

>> - the mentioned 'internal compiler error' mentioned by Taco rings a
>> bell, it's a reason why often saving/loading an 'int' goes via a
>> variable because compilers would optimize in a way that dumping
>> variables (ints) in more complex data structures gave issues
>>
>> - there are a few more places where using redundant temp vars are used
>> because during some operations memory can grow which can makes
>> pointers already set invalid, some of those have been sorted out
>> differently in the meantime)
> 
> Very interesting, hopefully the situation improved since.

i think there are still a few places

>> - talking of performance, one of the interesting things in the
>> beginning of development was that we noticed different (incremental)
>> versions to perform differently; for instance when math was opened up
>> the machinery became real slow, as if we crossed some boundary,
>> (compilation order of specific code modules mattered too); but when i
>> then updated my laptop it was fast again, not so much because of fhe
>> faster cpu but because the cpu cache was larger; compiler optimization
>> also kind of interfered (at that time ideas, experiments and binaries
>> came and went on a daily basis, we had quite some fun)
>>
>> - if performance is of concern, we also noticed (later one when luajit
>> enteres the scenary) that the settings for lua hashing matters, and
>> that luajit had pretty bad heuristics (tuned for url, we published
>> about that) so we used a different hashing there ...
> 
> Thank you for your insights and caring about performance!
one observation is that using macros instead of functions for 
performance makes little sense in a program like tex where one jumps 
over memory space all the time (compilers are quite okay in optimizing), 
but there can be differences between versions of e.g. gcc

in general, loss of performance in a tex engine is more due to the way 
macros are composed (or user styles for that matter)

another one is the performance of the console, i.e. kind of font, 
buffer, refresh delays defaults (i noticed that linux has large delays 
so that's the fastest, the new windows terminal is also fast) .. now 
that one is really measureable .. just try to run with piping the log to 
a file (all understandable) .. squeezing microseconds out of the binary 
can easily be nilled that way

Hans

-----------------------------------------------------------------
                                           Hans Hagen | PRAGMA ADE
               Ridderstraat 27 | 8061 GH Hasselt | The Netherlands
        tel: 038 477 53 69 | www.pragma-ade.nl | www.pragma-pod.nl
-----------------------------------------------------------------

From j.hagen at xs4all.nl  Wed Jul 21 16:01:35 2021
From: j.hagen at xs4all.nl (Hans Hagen)
Date: Wed, 21 Jul 2021 16:01:35 +0200
Subject: [Dev-luatex] Dump sharing - redundant copying/allocations
In-Reply-To: <cd661b24-7703-76fa-827b-6be99909df62@olsak.net>
References: <CCY3D8XA1G6U.294B58I2IDHF0@phobos>
 <cd661b24-7703-76fa-827b-6be99909df62@olsak.net>
Message-ID: <523f3e97-d3d6-1f24-750e-25a6788e75b9@xs4all.nl>

On 7/21/2021 3:13 PM, Petr Olsak wrote:
> Hello,
> 
> IMHO, the TeX engine can save a flag about Endianity to the format. When 
> a TeX engine reads such a format then it can check the current Endianity 
> with the saved one and do swapping only if they are different. But this 
> idea was'nt implemented: all formats use non-Intel Endianity (by 
> decision of develpers), so swapping are processed very often.
> 
> Moreover, saving lua bytecode to the format does not support different 
> architectures (It was mentioned in this thread too). IMHO, the classical 
> message "I am stymied" should be sufficient when a TeX engine reads a 
> format generated at different architecture.
luatex already has additional checking and would not load a format ... a 
saved version number for instance would come out differewnt in a non 
matching endian so as far we know we're okay

Hans


-----------------------------------------------------------------
                                           Hans Hagen | PRAGMA ADE
               Ridderstraat 27 | 8061 GH Hasselt | The Netherlands
        tel: 038 477 53 69 | www.pragma-ade.nl | www.pragma-pod.nl
-----------------------------------------------------------------

From lahcim8 at gmail.com  Wed Jul 21 16:08:15 2021
From: lahcim8 at gmail.com (=?utf-8?q?Michal_Vlas=C3=A1k?=)
Date: Wed, 21 Jul 2021 16:08:15 +0200
Subject: [Dev-luatex] Dump sharing - redundant copying/allocations
In-Reply-To: <34e821ec-9619-9ff3-52a7-6102028e8ade@xs4all.nl>
Message-ID: <CCYVL4HRIDJS.2WGI9S5MQOBJN@phobos>

On Wed Jul 21, 2021 at 3:57 PM CEST, Hans Hagen wrote:
> even if one would handle bytes in the lua bytecode, the bytecode itself
> is not portable (and i'm not even sure how luajit stuff fits in because
> luajit is even more platform specific

LuaJIT is actually really nice in this regard:

    "The generated bytecode is portable and can be loaded on any
    architecture that LuaJIT supports, independent of word size or
    endianess. However the bytecode compatibility versions must match."

> one observation is that using macros instead of functions for
> performance makes little sense in a program like tex where one jumps
> over memory space all the time (compilers are quite okay in optimizing),
> but there can be differences between versions of e.g. gcc

I think that modern compilers are good with inlining, one can get more
espcially when functions are marked static. So I incline towards
functions rather than macros.

> in general, loss of performance in a tex engine is more due to the way
> macros are composed (or user styles for that matter)
>
> another one is the performance of the console, i.e. kind of font,
> buffer, refresh delays defaults (i noticed that linux has large delays
> so that's the fastest, the new windows terminal is also fast) .. now
> that one is really measureable .. just try to run with piping the log
> to a file (all understandable) .. squeezing microseconds out of the
> binary can easily be nilled that way

Yeah, you are right, even for 18 lines of console output I mesaure more
noticable difference than with the mallocs and byte swapping.

Thanks,

Michal

From lahcim8 at gmail.com  Wed Jul 21 16:19:59 2021
From: lahcim8 at gmail.com (=?utf-8?q?Michal_Vlas=C3=A1k?=)
Date: Wed, 21 Jul 2021 16:19:59 +0200
Subject: [Dev-luatex] Dump sharing - redundant copying/allocations
In-Reply-To: <cd661b24-7703-76fa-827b-6be99909df62@olsak.net>
Message-ID: <CCYVU3X01MQS.29BV4XSPU74GN@phobos>

On Wed Jul 21, 2021 at 3:13 PM CEST, Petr Olsak wrote:
> IMHO, the TeX engine can save a flag about Endianity to the format.
> When a TeX engine reads such a format then it can check the current
> Endianity with the saved one and do swapping only if they are
> different. But this idea was'nt implemented: all formats use non-Intel
> Endianity (by decision of develpers), so swapping are processed very
> often.

Hans was quicker with his reply, but here is how I would put it:

The byte swapping on Little Endian isn't mandatory. One can compile with
-DNO_DUMP_SHARE.

> Moreover, saving lua bytecode to the format does not support different
> architectures (It was mentioned in this thread too). IMHO, the
> classical message "I am stymied" should be sufficient when a TeX
> engine reads a format generated at different architecture.

This is exactly what I get when loading Big Endian format on Little
Endian:

    (Fatal format file error; I'm stymied)

The BE/LE check is actually done as a side effect of checking the magic
number (0x57325458, the first thing that gets checked).

Michal VlasÃ¡k

From j.hagen at xs4all.nl  Wed Jul 21 16:31:29 2021
From: j.hagen at xs4all.nl (Hans Hagen)
Date: Wed, 21 Jul 2021 16:31:29 +0200
Subject: [Dev-luatex] Dump sharing - redundant copying/allocations
In-Reply-To: <CCYVL4HRIDJS.2WGI9S5MQOBJN@phobos>
References: <CCYVL4HRIDJS.2WGI9S5MQOBJN@phobos>
Message-ID: <66cb3918-625c-3788-db76-947c9156dfc5@xs4all.nl>

On 7/21/2021 4:08 PM, Michal VlasÃ¡k wrote:
> On Wed Jul 21, 2021 at 3:57 PM CEST, Hans Hagen wrote:
>> even if one would handle bytes in the lua bytecode, the bytecode itself
>> is not portable (and i'm not even sure how luajit stuff fits in because
>> luajit is even more platform specific
> 
> LuaJIT is actually really nice in this regard:
> 
>      "The generated bytecode is portable and can be loaded on any
>      architecture that LuaJIT supports, independent of word size or
>      endianess. However the bytecode compatibility versions must match."

Ok, btw, these bytecode compatibility versions are not guaranteed the 
same within intermediate updates (so for instance during the 5.4 dev 
stage they changed .. i actually took care of that but didn't want to 
patch the official code - with a sub number - any more so i dropped that)

>> one observation is that using macros instead of functions for
>> performance makes little sense in a program like tex where one jumps
>> over memory space all the time (compilers are quite okay in optimizing),
>> but there can be differences between versions of e.g. gcc
> 
> I think that modern compilers are good with inlining, one can get more
> espcially when functions are marked static. So I incline towards
> functions rather than macros.

also, local optimization is better

>> in general, loss of performance in a tex engine is more due to the way
>> macros are composed (or user styles for that matter)
>>
>> another one is the performance of the console, i.e. kind of font,
>> buffer, refresh delays defaults (i noticed that linux has large delays
>> so that's the fastest, the new windows terminal is also fast) .. now
>> that one is really measureable .. just try to run with piping the log
>> to a file (all understandable) .. squeezing microseconds out of the
>> binary can easily be nilled that way
> 
> Yeah, you are right, even for 18 lines of console output I mesaure more
> noticable difference than with the mallocs and byte swapping.
it has to do with the fact that tex outputs on a char by char basis with 
different criteria for log and console, and most consoles accumulate 
some before flushing, sometimes upto 200 ms

the old windows console output per-char so that one was hurt most, but 
there were plenty ways around that; on osx fancy font features in a 
console could also work out bad

Hans

-----------------------------------------------------------------
                                           Hans Hagen | PRAGMA ADE
               Ridderstraat 27 | 8061 GH Hasselt | The Netherlands
        tel: 038 477 53 69 | www.pragma-ade.nl | www.pragma-pod.nl
-----------------------------------------------------------------

From reinhard.kotucha at web.de  Thu Jul 22 01:01:12 2021
From: reinhard.kotucha at web.de (Reinhard Kotucha)
Date: Thu, 22 Jul 2021 01:01:12 +0200
Subject: [Dev-luatex] Dump sharing - redundant copying/allocations
In-Reply-To: <34e821ec-9619-9ff3-52a7-6102028e8ade@xs4all.nl>
References: <CCYSTYAWOWT1.2AS75U7FLLLHE@phobos>
 <34e821ec-9619-9ff3-52a7-6102028e8ade@xs4all.nl>
Message-ID: <24824.42808.744274.757150@gargle.gargle.HOWL>

On 2021-07-21 at 15:57:00 +0200, Hans Hagen wrote:

 > the sharing made sense in the time when one ran tex from a dvd in
 > which case all binaries shared the same precooked formats (or on
 > networkshares servingb multiple architectures) but afaik running
 > from dvd was dropped and hardly anyone runs multiple platforms from
 > one share (those who do can probably figure out some trick)

It still makes sense.  It's true that we currently can't provide a
live system on a DVD but it's still possible to install a live system
on USB sticks.  User groups can't provide USB sticks because they are
too expensive.

Installing TL on a server is certainly much more common than you
think.  I'm doing this for years at work.  And some of my workflows
heavily depend on TeX Live's portability.

So whenever possible, please don't give up this great feature.

Regards,
  Reinhard

--
------------------------------------------------------------------
Reinhard Kotucha                            Phone: +49-511-3373112
Marschnerstr. 25
D-30167 Hannover                    mailto:reinhard.kotucha at web.de
------------------------------------------------------------------

From luigi.scarso at gmail.com  Thu Jul 29 09:54:20 2021
From: luigi.scarso at gmail.com (luigi scarso)
Date: Thu, 29 Jul 2021 09:54:20 +0200
Subject: [Dev-luatex] LuaTeX doesn't discard empty paragraphs when
 textdir is used
In-Reply-To: <20210621145436.ek3h2qlghjfk2heh@beeblebrox>
References: <20210621145436.ek3h2qlghjfk2heh@beeblebrox>
Message-ID: <CAG5iGsAf8-=4q1kB6VLHdPZ9BCdjbg0mxxBj_qCt2UsmxT6dLQ@mail.gmail.com>

On Mon, Jun 21, 2021 at 5:03 PM Marcel KrÃ¼ger <tex at 2krueger.de> wrote:

> Hi,
>
> consider the following plain LuaTeX document:
>
> \textdir TRT
> \noindent\par
> \bye
>
> without the `\textdir TRT` line or with `\textdir TLT`, this would lead
> to "warning  (pdf backend): no pages of output.", but with the non
> default "\textdir", it creates an empty (except for the page number) page
> instead.
>
> This can be avoided by setting \pardir too:
>
> \textdir TRT\pardir TRT
> \noindent\par
> \bye
>
> again produces no output, but adding a group around it reintroduces the
> issue:
>
> \begingroup
> \textdir TRT\pardir TRT
> \noindent\par
> \endgroup
> \bye
>
> leads to an empty page.
>
> Of course similar things happen not only for otherwise empty documents:
> Instead of empty paragraphs disappearing, they add empty lines.
>
> Together, this is not only inconsistent with other engines which always
> discard empty paragraphs, but also leads to hard to predict behavior
> (especially for users who are not familiar with the implementation of
> LuaTeX's directional system), so I think it would be great if LuaTeX
> could always remove such empty paragraphs.
>
>
(sorry for the delay)
Do you have  a patch to propose  ?

-- 
luigi
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mailman.ntg.nl/pipermail/dev-luatex/attachments/20210729/1e15f39d/attachment.htm>

From j.hagen at xs4all.nl  Thu Jul 29 14:21:01 2021
From: j.hagen at xs4all.nl (Hans Hagen)
Date: Thu, 29 Jul 2021 14:21:01 +0200
Subject: [Dev-luatex] LuaTeX doesn't discard empty paragraphs when
 textdir is used
In-Reply-To: <CAG5iGsAf8-=4q1kB6VLHdPZ9BCdjbg0mxxBj_qCt2UsmxT6dLQ@mail.gmail.com>
References: <20210621145436.ek3h2qlghjfk2heh@beeblebrox>
 <CAG5iGsAf8-=4q1kB6VLHdPZ9BCdjbg0mxxBj_qCt2UsmxT6dLQ@mail.gmail.com>
Message-ID: <ce4878b1-879e-5eab-bfee-ce459d1bc894@xs4all.nl>

On 7/29/2021 9:54 AM, luigi scarso wrote:
> 
> 
> On Mon, Jun 21, 2021 at 5:03 PM Marcel KrÃ¼ger <tex at 2krueger.de 
> <mailto:tex at 2krueger.de>> wrote:
> 
>     Hi,
> 
>     consider the following plain LuaTeX document:
> 
>     \textdir TRT
>     \noindent\par
>     \bye
> 
>     without the `\textdir TRT` line or with `\textdir TLT`, this would lead
>     to "warningÂ  (pdf backend): no pages of output.", but with the non
>     default "\textdir", it creates an empty (except for the page number)
>     page
>     instead.
> 
>     This can be avoided by setting \pardir too:
> 
>     \textdir TRT\pardir TRT
>     \noindent\par
>     \bye
> 
>     again produces no output, but adding a group around it reintroduces the
>     issue:
> 
>     \begingroup
>     \textdir TRT\pardir TRT
>     \noindent\par
>     \endgroup
>     \bye
> 
>     leads to an empty page.
> 
>     Of course similar things happen not only for otherwise empty documents:
>     Instead of empty paragraphs disappearing, they add empty lines.
> 
>     Together, this is not only inconsistent with other engines which always
>     discard empty paragraphs, but also leads to hard to predict behavior
>     (especially for users who are not familiar with the implementation of
>     LuaTeX's directional system), so I think it would be great if LuaTeX
>     could always remove such empty paragraphs.
> 
> 
> (sorry for the delay)
> Do you have Â a patch to proposeÂ  ?
it's a side effect of the direction handler picking up states ... kind 
of tricky code but i can probably come up with a fix (maybe under 
parameter control)

(of course normally a macro package will catch these kind of things if 
needed)

Hans


-----------------------------------------------------------------
                                           Hans Hagen | PRAGMA ADE
               Ridderstraat 27 | 8061 GH Hasselt | The Netherlands
        tel: 038 477 53 69 | www.pragma-ade.nl | www.pragma-pod.nl
-----------------------------------------------------------------

From luigi.scarso at gmail.com  Thu Jul 29 14:27:59 2021
From: luigi.scarso at gmail.com (luigi scarso)
Date: Thu, 29 Jul 2021 14:27:59 +0200
Subject: [Dev-luatex] LuaTeX doesn't discard empty paragraphs when
 textdir is used
In-Reply-To: <ce4878b1-879e-5eab-bfee-ce459d1bc894@xs4all.nl>
References: <20210621145436.ek3h2qlghjfk2heh@beeblebrox>
 <CAG5iGsAf8-=4q1kB6VLHdPZ9BCdjbg0mxxBj_qCt2UsmxT6dLQ@mail.gmail.com>
 <ce4878b1-879e-5eab-bfee-ce459d1bc894@xs4all.nl>
Message-ID: <CAG5iGsAwf+h3Gv2Z96rY_kSxr5ezEvT515HVNT0BNuzSX2Zk3Q@mail.gmail.com>

On Thu, Jul 29, 2021 at 2:21 PM Hans Hagen <j.hagen at xs4all.nl> wrote:

> it's a side effect of the direction handler picking up states ... kind
> of tricky code but i can probably come up with a fix (maybe under
> parameter control)


yes,  a parameter control is the right way.

-- 
luigi
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mailman.ntg.nl/pipermail/dev-luatex/attachments/20210729/6301685c/attachment.htm>

