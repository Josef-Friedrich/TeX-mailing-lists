From jfbu at free.fr  Mon Aug  2 21:35:50 2021
From: jfbu at free.fr (jfbu)
Date: Mon, 2 Aug 2021 21:35:50 +0200
Subject: [luatex] how many bytes for fontdimens?
Message-ID: <4655BAD2-CA3D-496A-9423-5B6718FBAB13@free.fr>

Hi,
I would like to know if luatex (as I expect) uses 32bits storage per \fontdimen of a given font.

Or perhaps it depends on the architecture?

Regards,
Jean-Fran?ois





From jfbu at free.fr  Mon Aug  2 21:37:08 2021
From: jfbu at free.fr (jfbu)
Date: Mon, 2 Aug 2021 21:37:08 +0200
Subject: [luatex] how many bytes for fontdimens?
In-Reply-To: <4655BAD2-CA3D-496A-9423-5B6718FBAB13@free.fr>
References: <4655BAD2-CA3D-496A-9423-5B6718FBAB13@free.fr>
Message-ID: <B3909FA6-8DB2-4691-9D63-9D21D3D3A4F9@free.fr>

forgot to mention that I am aware a \fontdimen is limited to 2**30 strictly anyhow

but my question is whether such ? arrays ? are stored 32bits or 64bits itemwise

> Le 2 ao?t 2021 ? 21:35, jfbu <jfbu at free.fr> a ?crit :
> 
> Hi,
> I would like to know if luatex (as I expect) uses 32bits storage per \fontdimen of a given font.
> 
> Or perhaps it depends on the architecture?
> 
> Regards,
> Jean-Fran?ois
> 
> 
> 



From j.hagen at xs4all.nl  Tue Aug  3 09:09:47 2021
From: j.hagen at xs4all.nl (Hans Hagen)
Date: Tue, 3 Aug 2021 09:09:47 +0200
Subject: [luatex] how many bytes for fontdimens?
In-Reply-To: <B3909FA6-8DB2-4691-9D63-9D21D3D3A4F9@free.fr>
References: <4655BAD2-CA3D-496A-9423-5B6718FBAB13@free.fr>
 <B3909FA6-8DB2-4691-9D63-9D21D3D3A4F9@free.fr>
Message-ID: <3313d759-917a-e052-787b-ae6755385736@xs4all.nl>

On 8/2/2021 9:37 PM, jfbu wrote:
> forgot to mention that I am aware a \fontdimen is limited to 2**30 strictly anyhow
> 
> but my question is whether such ? arrays ? are stored 32bits or 64bits itemwise
it happens to be an array of 32 bit integers (that grows on demand) but 
such implementaiton details are unspecified (could as well have been a 
sparse array in which case each entry that is actually set has more

also, the fact that it grow is a sort of side effect of the fact that 
tfm fonts can have 7 or more, but 7 are used, for text upto more for 
math fonts

so, i wouldn't rely on these properties too much

Hans

-----------------------------------------------------------------
                                           Hans Hagen | PRAGMA ADE
               Ridderstraat 27 | 8061 GH Hasselt | The Netherlands
        tel: 038 477 53 69 | www.pragma-ade.nl | www.pragma-pod.nl
-----------------------------------------------------------------

From jfbu at free.fr  Tue Aug  3 09:45:45 2021
From: jfbu at free.fr (jfbu)
Date: Tue, 3 Aug 2021 09:45:45 +0200
Subject: [luatex] how many bytes for fontdimens?
In-Reply-To: <3313d759-917a-e052-787b-ae6755385736@xs4all.nl>
References: <4655BAD2-CA3D-496A-9423-5B6718FBAB13@free.fr>
 <B3909FA6-8DB2-4691-9D63-9D21D3D3A4F9@free.fr>
 <3313d759-917a-e052-787b-ae6755385736@xs4all.nl>
Message-ID: <E724E143-A498-4345-BEFB-768939EDF232@free.fr>

Hi,

> Le 3 ao?t 2021 ? 09:09, Hans Hagen <j.hagen at xs4all.nl> a ?crit :
> 
> On 8/2/2021 9:37 PM, jfbu wrote:
>> forgot to mention that I am aware a \fontdimen is limited to 2**30 strictly anyhow
>> but my question is whether such ? arrays ? are stored 32bits or 64bits itemwise
> it happens to be an array of 32 bit integers (that grows on demand) but such implementaiton details are unspecified (could as well have been a sparse array in which case each entry that is actually set has more
> 
> also, the fact that it grow is a sort of side effect of the fact that tfm fonts can have 7 or more, but 7 are used, for text upto more for math fonts
> 
> so, i wouldn't rely on these properties too much

Thanks! 

Reason I asked is because I contributed an Eratosthenes Prime sieve to a github site comparing a whole bunch of langages and it is asked there to specify whether the ? arrays ? use 1bit, 8bits, 32bits, or 64bits (or ? unknown ?) per (potential) prime.

https://github.com/PlummersSoftwareLLC/Primes/blob/drag-race/CONTRIBUTING.md#flag-storage <https://github.com/PlummersSoftwareLLC/Primes/blob/drag-race/CONTRIBUTING.md#flag-storage>

I am using luatex for the benchmark because even setting pdftex?s font_mem_size at its maximum TeXLive setting, the memory is at risk of being exhausted on current personal computers  from the condition that the benchmark must iterate at least until a duration of 5 seconds and each iteration re-in allocates a \fontdimen ? array ? (in the case at hand about 500,000 entries are needed to sieve up to 1,000,000 and memory will get exhausted before the 300th pass)

Also it seems luatex runs comparatively faster once the sieving range is large enough (the instantiation step which requires extending dynamically does take some time).

I will thus modify the ? bit count ? tag of my ? solution ? from unknown to 32bits, thanks to your answer, knowing though that this remains officially unspecified. But the Dockerfile which I was asked to include, and which their benchmarking uses, pulls a texlive-minimal based image dating back to 2018.

Perhaps someone here will be interested into contributing a genuine luatex (i.e. using Lua) solution (my code uses only Knuth TeX; there is also a LaTeX3 code also on the github site).

There is already at least one Lua contribution. I don?t know if a genuine luatex would have to be categorized under ? PrimeTeX ? or ? PrimeLua ? ...

... in particular a LuaTeX genuine solution may have a way to use an ? array ? not based on font dimension parameters.

One particular point I don?t know is whether LuaTeX would allow a ? faithful ? solution: this seems to mean roughly a class-encapsulated one (it is hard to understand what they precisely mean in their guidelines), which I could not really emulate in my code due to global nature of fontdimen assignments.

(I also experimented with  a csname based approach but never could reach comparable speed to fontdimen arrays ; and this required extending other parts of the memory)

Here is a link to how the various implementations sort out currently on one specific machine:

https://plummerssoftwarellc.github.io/PrimeView/?sc=dt&sd=True&rc=30 <https://plummerssoftwarellc.github.io/PrimeView/?sc=dt&sd=True&rc=30>


Thanks,

Jean-Fran?ois

> 
> Hans
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://tug.org/pipermail/luatex/attachments/20210803/ba366631/attachment.html>

From j.hagen at xs4all.nl  Tue Aug  3 12:49:03 2021
From: j.hagen at xs4all.nl (Hans Hagen)
Date: Tue, 3 Aug 2021 12:49:03 +0200
Subject: [luatex] how many bytes for fontdimens?
In-Reply-To: <E724E143-A498-4345-BEFB-768939EDF232@free.fr>
References: <4655BAD2-CA3D-496A-9423-5B6718FBAB13@free.fr>
 <B3909FA6-8DB2-4691-9D63-9D21D3D3A4F9@free.fr>
 <3313d759-917a-e052-787b-ae6755385736@xs4all.nl>
 <E724E143-A498-4345-BEFB-768939EDF232@free.fr>
Message-ID: <25af7325-829b-6bb7-9d20-09a8db8a7c3d@xs4all.nl>

On 8/3/2021 9:45 AM, jfbu wrote:
> Hi,
> 
>> Le 3 ao?t 2021 ? 09:09, Hans Hagen <j.hagen at xs4all.nl 
>> <mailto:j.hagen at xs4all.nl>> a ?crit :
>>
>> On 8/2/2021 9:37 PM, jfbu wrote:
>>> forgot to mention that I am aware a \fontdimen is limited to 2**30 
>>> strictly anyhow
>>> but my question is whether such ? arrays ? are stored 32bits or 
>>> 64bits itemwise
>> it happens to be an array of 32 bit integers (that grows on demand) 
>> but such implementaiton details are unspecified (could as well have 
>> been a sparse array in which case each entry that is actually set has more
>>
>> also, the fact that it grow is a sort of side effect of the fact that 
>> tfm fonts can have 7 or more, but 7 are used, for text upto more for 
>> math fonts
>>
>> so, i wouldn't rely on these properties too much
> 
> Thanks!
> 
> Reason I asked is because I contributed an Eratosthenes Prime sieve to a 
> github site comparing a whole bunch of langages and it is asked there to 
> specify whether the ??arrays?? use 1bit, 8bits, 32bits, or 64bits (or 
> ??unknown??) per (potential) prime.
> 
> https://github.com/PlummersSoftwareLLC/Primes/blob/drag-race/CONTRIBUTING.md#flag-storage 
> <https://github.com/PlummersSoftwareLLC/Primes/blob/drag-race/CONTRIBUTING.md#flag-storage>

ha, i've seen that one a few weeks ago (after some yt video) and to be 
honnest it's one of these useless speed comparisons (can be fun, but 
useless as one compares languages with different objectives and doing 
some prime stuff is hardly representative for usage)

> I am using luatex for the benchmark because even setting pdftex?s 
> font_mem_size at its maximum TeXLive setting, the memory is at risk of 
> being exhausted on current personal computers ?from the condition that 
> the benchmark must iterate at least until a duration of 5 seconds and 
> each iteration re-in allocates a \fontdimen ??array?? (in the case at 
> hand about 500,000 entries are needed to sieve up to 1,000,000 and 
> memory will get exhausted before the 300th pass)
> 
> Also it seems luatex runs comparatively faster once the sieving range is 
> large enough (the instantiation step which requires extending 
> dynamically does take some time).

hm, just allocate the largest fontdimen you need first, that will make 
the fontdimen array grow at the beginning only (instead of at each step)

> I will thus modify the ??bit count?? tag of my ??solution?? from unknown 
> to 32bits, thanks to your answer, knowing though that this remains 
> officially unspecified. But the Dockerfile which I was asked to include, 
> and which their benchmarking uses, pulls a texlive-minimal based image 
> dating back to 2018.
> 
> Perhaps someone here will be interested into contributing a genuine 
> luatex (i.e. using Lua) solution (my code uses only Knuth TeX; there is 
> also a LaTeX3 code also on the github site).

a lua solution in luatex is just a lua solution -)

> There is already at least one Lua contribution. I don?t know if a 
> genuine luatex would have to be categorized under ??PrimeTeX?? or 
> ??PrimeLua?? ...
> 
> ... in particular a LuaTeX genuine solution may have a way to use an 
> ??array?? not based on font dimension parameters.

mixing lua and tex will also introduce lua call overhead so there is no 
gain there (maybe let lua do the sqrt but then you can well do all in lua)

my guess is that the sqrt is the bottleneck

fontdimens are actually bnto that slow not that slow because they are 
(1) global so no save stack overhead, and (2) directly accessible 
because they are part of the font structure (so no tex dimen access 
overhead)

also, using etex \dimexpr is also slower than the simple operators

> One particular point I don?t know is whether LuaTeX would allow a 
> ??faithful?? solution: this seems to mean roughly a class-encapsulated 
> one (it is hard to understand what they precisely mean in their 
> guidelines), which I could not really emulate in my code due to global 
> nature of fontdimen assignments.

hm, do you really need local?

if you use csnames, then you can also consider using \chardef's for 
numbers (these obey grouping)

> (I also experimented with ?a csname based approach but never could reach 
> comparable speed to fontdimen arrays ; and this required extending other 
> parts of the memory)

in luatex csname is costly because of the serialization (pdftex is 
probably faster because there is no utf related overhead)

> Here is a link to how the various implementations sort out currently on 
> one specific machine:
> 
> https://plummerssoftwarellc.github.io/PrimeView/?sc=dt&sd=True&rc=30 
> <https://plummerssoftwarellc.github.io/PrimeView/?sc=dt&sd=True&rc=30>
the lua solution they post is not only somewhat slow but also makes some 
(imo wrong, but who am i to claim) assumptions about how lua stores data 
so it was not that hard to make a variant that was over 200 times faster

because i have a relative old laptop i can't compare with the numbers 
for e.g. c there (of course lua will be slower) but as i consider these 
shootouts useles anyway, i didn't want to spend more time on it (all 
that docker stuff and such) nor comment on the posted lua code (i never 
comment on code anyway, unless I know someone well and we can discuss 
specific issues out of mutual interest)

(messing with bits and storing efficiently in lua probably costs more 
than it saves, and the same might be true in tex)

Hans

-----------------------------------------------------------------
                                           Hans Hagen | PRAGMA ADE
               Ridderstraat 27 | 8061 GH Hasselt | The Netherlands
        tel: 038 477 53 69 | www.pragma-ade.nl | www.pragma-pod.nl
-----------------------------------------------------------------

From jfbu at free.fr  Tue Aug  3 15:26:22 2021
From: jfbu at free.fr (jfbu)
Date: Tue, 3 Aug 2021 15:26:22 +0200
Subject: [luatex] how many bytes for fontdimens?
In-Reply-To: <25af7325-829b-6bb7-9d20-09a8db8a7c3d@xs4all.nl>
References: <4655BAD2-CA3D-496A-9423-5B6718FBAB13@free.fr>
 <B3909FA6-8DB2-4691-9D63-9D21D3D3A4F9@free.fr>
 <3313d759-917a-e052-787b-ae6755385736@xs4all.nl>
 <E724E143-A498-4345-BEFB-768939EDF232@free.fr>
 <25af7325-829b-6bb7-9d20-09a8db8a7c3d@xs4all.nl>
Message-ID: <E9F3792B-3D14-48B2-AB45-81E1105402E3@free.fr>



> Le 3 ao?t 2021 ? 12:49, Hans Hagen <j.hagen at xs4all.nl> a ?crit :
> 
> On 8/3/2021 9:45 AM, jfbu wrote:
>> Hi,
>>> Le 3 ao?t 2021 ? 09:09, Hans Hagen <j.hagen at xs4all.nl <mailto:j.hagen at xs4all.nl>> a ?crit :
>>> 
>>> On 8/2/2021 9:37 PM, jfbu wrote:
>>>> forgot to mention that I am aware a \fontdimen is limited to 2**30 strictly anyhow
>>>> but my question is whether such ? arrays ? are stored 32bits or 64bits itemwise
>>> it happens to be an array of 32 bit integers (that grows on demand) but such implementaiton details are unspecified (could as well have been a sparse array in which case each entry that is actually set has more
>>> 
>>> also, the fact that it grow is a sort of side effect of the fact that tfm fonts can have 7 or more, but 7 are used, for text upto more for math fonts
>>> 
>>> so, i wouldn't rely on these properties too much
>> Thanks!
>> Reason I asked is because I contributed an Eratosthenes Prime sieve to a github site comparing a whole bunch of langages and it is asked there to specify whether the ? arrays ? use 1bit, 8bits, 32bits, or 64bits (or ? unknown ?) per (potential) prime.
>> https://github.com/PlummersSoftwareLLC/Primes/blob/drag-race/CONTRIBUTING.md#flag-storage <https://github.com/PlummersSoftwareLLC/Primes/blob/drag-race/CONTRIBUTING.md#flag-storage>
> 
> ha, i've seen that one a few weeks ago (after some yt video) and to be honnest it's one of these useless speed comparisons (can be fun, but useless as one compares languages with different objectives and doing some prime stuff is hardly representative for usage)


It seems the C++ solutions listed as fastest do quite a part of the job at compile time not at execution time...

The chosen topic (basic sieve and possibly some refinements like ? wheel ? algorithms) seems to test the capacity of the language to access successive memory addresses in the most efficient way and/or perhaps to move bit patterns around.

Also, it stops at having the array done, but does not address how you use this after the fact.

If the final aim is to print out primes to a file the bottleneck may be rather into the conversion of the bit pattern into explicit ascii bytes... 

For example, if I produce using lualatex a pdf file of all primes less than 999,999,999, most of the time by far is consumed by the typesetting phase (something like 1350 pages, 10 columns per page)

> 
>> I am using luatex for the benchmark because even setting pdftex?s font_mem_size at its maximum TeXLive setting, the memory is at risk of being exhausted on current personal computers  from the condition that the benchmark must iterate at least until a duration of 5 seconds and each iteration re-in allocates a \fontdimen ? array ? (in the case at hand about 500,000 entries are needed to sieve up to 1,000,000 and memory will get exhausted before the 300th pass)
>> Also it seems luatex runs comparatively faster once the sieving range is large enough (the instantiation step which requires extending dynamically does take some time).
> 
> hm, just allocate the largest fontdimen you need first, that will make the fontdimen array grow at the beginning only (instead of at each step)
> 

This is what I do except for one auxiliary array in the ? wheel ? because I felt it would be cheating to allocate the 480 slots to start with. I could however have allocated say 1155 = 2310/2 (2310 = 2 * 3 * 5 * 7 *11) slots, wasting some.

But this is executed only once anyhow, at loading time of the ? sieve library ? independently of the number of passes done during benchmark. Maybe I will do the change for some small gain.

>> I will thus modify the ? bit count ? tag of my ? solution ? from unknown to 32bits, thanks to your answer, knowing though that this remains officially unspecified. But the Dockerfile which I was asked to include, and which their benchmarking uses, pulls a texlive-minimal based image dating back to 2018.
>> Perhaps someone here will be interested into contributing a genuine luatex (i.e. using Lua) solution (my code uses only Knuth TeX; there is also a LaTeX3 code also on the github site).
> 
> a lua solution in luatex is just a lua solution -)
> 
>> There is already at least one Lua contribution. I don?t know if a genuine luatex would have to be categorized under ? PrimeTeX ? or ? PrimeLua ? ...
>> ... in particular a LuaTeX genuine solution may have a way to use an ? array ? not based on font dimension parameters.
> 
> mixing lua and tex will also introduce lua call overhead so there is no gain there (maybe let lua do the sqrt but then you can well do all in lua)
> 
> my guess is that the sqrt is the bottleneck
> 
> fontdimens are actually bnto that slow not that slow because they are (1) global so no save stack overhead, and (2) directly accessible because they are part of the font structure (so no tex dimen access overhead)
> 
> also, using etex \dimexpr is also slower than the simple operators

Not to mention that etex division rounds which sometimes is more inconvenient than truncating

On the other hand having \numexpr at once disposal allows to more easily have some namespacing of auxiliary counters, using macros instead of \count's

> 
>> One particular point I don?t know is whether LuaTeX would allow a ? faithful ? solution: this seems to mean roughly a class-encapsulated one (it is hard to understand what they precisely mean in their guidelines), which I could not really emulate in my code due to global nature of fontdimen assignments.
> 
> hm, do you really need local?

honestly I don?t know exactly what they are aiming at, but I guess basically some piece of code you can re-use in arbitrary code as a library. Global is perhaps not that bad, but having no way to release the memory disqualifies it for faithfulness I believe. The memory can be marked for re-use, but one can not extend the array size after the fact.

anyway, at least some namespace should be added to my solution, I did it (weirdly) for some aspects but not all


> 
> if you use csnames, then you can also consider using \chardef's for numbers (these obey grouping)

ok, the extended range of \char in luatex would indeed help if one needed to store numbers up to the sieving range of 1,000,000. I have some alternative algorithm needing this kind of storage, but a priori when I mentioned csnames it was only to code a ? on/off ? situation (testing if some number has been marked for composite or no via an \ifcsname, using e-TeX for convenience). Unfortunately this has the overhead of requiring to convert a number into explicit digit tokens.

or is there a way in luatex to tag objects by numbers not having been converted to digit tokens?


> 
>> (I also experimented with  a csname based approach but never could reach comparable speed to fontdimen arrays ; and this required extending other parts of the memory)
> 
> in luatex csname is costly because of the serialization (pdftex is probably faster because there is no utf related overhead)

I did not compare the two. For the fontdimen based approach, at first pdftex looks faster but on closer look for ranges higher than 1,000,000, it seems luatex gets relatively faster, regarding the process of sieving itself.

For example I get this typically on my (slow) machine for sieving up to 100,000,000:

pdftex

Instantiate object for sieving up to 100000000...
...done (0.2322s)
Sieving...
...done (29.4603s)
Outputting to file listofprimes-100000000.txt...
5761455 primes were written to file listofprimes-100000000.txt
...done (22.96228s)
 ) )
No pages of output.
Transcript written on wheel_primestofile.log.

real	0m52.898s
user	0m52.502s
sys	0m0.281s

luatex
Instantiate object for sieving up to 100000000...
...done (3.84619s)
Sieving...
...done (26.5682s)
Outputting to file listofprimes-100000000.txt...
5761455 primes were written to file listofprimes-100000000.txt
...done (28.48254s)
))
warning  (pdf backend): no pages of output.
Transcript written on wheel_primestofile.log.

real	0m59.444s
user	0m58.895s
sys	0m0.445s


The sieving itself seems being done faster by luatex. For some reason the ? write to file ? part appears slower. As  the ? write to a file ? was not part of benchmark, I simply issue one \write per prime and it is quite possible gathering together the \write?s by batches could improve.  Not tested.

Something I don?t understand is that the spread between the ? base ? algorithm (basically the elementary school one, but using only odd numbers from the start, and maybe starting at factor*factor and going by steps of 2*factor) and the ? wheel ? algorithm (with some primes already sieved out) seems to be greater with pdftex than with luatex: perhaps 2.8 or 2.9 speed gain for pdftex, but only like 2.3 or at most 2.5 with luatex.

> 
>> Here is a link to how the various implementations sort out currently on one specific machine:
>> https://plummerssoftwarellc.github.io/PrimeView/?sc=dt&sd=True&rc=30 <https://plummerssoftwarellc.github.io/PrimeView/?sc=dt&sd=True&rc=30>
> the lua solution they post is not only somewhat slow but also makes some (imo wrong, but who am i to claim) assumptions about how lua stores data so it was not that hard to make a variant that was over 200 times faster

ah very interesting. I was also very surprised that the Lua solution appeared so slow relatively.

Notice by the way that the first Python solution is also very slow... slower than my tex one! (to be fair, slower than my ? wheel ? one, but Python uses the ? base ? algorithm)

> 
> because i have a relative old laptop i can't compare with the numbers for e.g. c there (of course lua will be slower)

I think the machine they use for the ? PrimeView ? is also relatively old (2013). Mine is 2012 and is faster than theirs.

> but as i consider these shootouts useles anyway, i didn't want to spend more time on it (all that docker stuff and such)

I confirm I have spent between 5x and 10x more time with these contributing requirements than with the TeX coding itself. In the end the Dockerfile is very simple but it went through more complicated intermediate versions. I did not want to pull a 4G or 5G texlive image though and initially I was using pdftex but needed to understand how to let it acquire more memory, then I used luatex but I needed to add \pdfresettimer, which finally I did via the \directlua in the tex file itself.

> nor comment on the posted lua code (i never comment on code anyway, unless I know someone well and we can discuss specific issues out of mutual interest)

This is wise indeed.

I know some under-optimal aspects of my contribution and I have not tested some aspects like whether at some location I should use \ifdim rather than \ifnum, or even some other way of testing. I also hesitated regarding the wheel algorithm between using only one giant array, or 480 smaller ones indexed on class modulo 2310, the latter approach reducing the memory impact (by a factor of 1155/480).

Also let me point out that during the various squashes before my PR was merged, I accidentally lost crediting the fact that the \Replicate I use, copied over from xint with removal of e-TeX, was originally basically cloned from the LaTeX3 and has a decades old history I trust.

I have also not tried to optimise how this \Replicate should be used, deciding to nest it with an inner one replicating 1000 times, but never testing if that was actually good.  As the benchmarking overthere is done only for 1,000,000 range, there is danger also to make code seemingly general but in fact tailored for that range only, which would not be entirely fair, imho.


> 
> (messing with bits and storing efficiently in lua probably costs more than it saves, and the same might be true in tex)


Sadly, the nice coincidence that TeX dimensions allow 30 bits and that 30=2*3*5 does not help much as I know no native TeX way to do bitwise operations. We only need two: setting a bit and querying it. This can de done with existing TeX arithmetic and/or macros but will be costly. I did not even try it out.

I also know of no way to initialize a \fontdimen array of a specific size with a specific pattern such as  some non-zero dimension repeated all the way, apart naturally to go through assigning all of them one by one, where the fact that always the same value is used brings no gain whatsoever.

Jean-Fran?ois

> 
> Hans
> 
> -----------------------------------------------------------------
>                                          Hans Hagen | PRAGMA ADE
>              Ridderstraat 27 | 8061 GH Hasselt | The Netherlands
>       tel: 038 477 53 69 | www.pragma-ade.nl | www.pragma-pod.nl
> -----------------------------------------------------------------



From jfbu at free.fr  Tue Aug  3 15:31:31 2021
From: jfbu at free.fr (jfbu)
Date: Tue, 3 Aug 2021 15:31:31 +0200
Subject: [luatex] how many bytes for fontdimens?
In-Reply-To: <E9F3792B-3D14-48B2-AB45-81E1105402E3@free.fr>
References: <4655BAD2-CA3D-496A-9423-5B6718FBAB13@free.fr>
 <B3909FA6-8DB2-4691-9D63-9D21D3D3A4F9@free.fr>
 <3313d759-917a-e052-787b-ae6755385736@xs4all.nl>
 <E724E143-A498-4345-BEFB-768939EDF232@free.fr>
 <25af7325-829b-6bb7-9d20-09a8db8a7c3d@xs4all.nl>
 <E9F3792B-3D14-48B2-AB45-81E1105402E3@free.fr>
Message-ID: <9D5ED898-5E23-4AFB-8827-ECC7F2B1546A@free.fr>



> Le 3 ao?t 2021 ? 15:26, jfbu <jfbu at free.fr> a ?crit :
> 
> For example, if I produce using lualatex a pdf file of all primes less than 999,999,999, most of the time by far is consumed by the typesetting phase (something like 1350 pages, 10 columns per page)


I should have read again. I meant sieving range of 100,000,000 (not 999,999,999) which finds 5,761,455 primes which ends up into a PDF with circa the 1350 pages mentioned. It would be about 10 times more for the 10 fold range.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://tug.org/pipermail/luatex/attachments/20210803/aa91ac83/attachment.html>

From luigi.scarso at gmail.com  Tue Aug  3 15:32:01 2021
From: luigi.scarso at gmail.com (luigi scarso)
Date: Tue, 3 Aug 2021 15:32:01 +0200
Subject: [luatex] how many bytes for fontdimens?
In-Reply-To: <E9F3792B-3D14-48B2-AB45-81E1105402E3@free.fr>
References: <4655BAD2-CA3D-496A-9423-5B6718FBAB13@free.fr>
 <B3909FA6-8DB2-4691-9D63-9D21D3D3A4F9@free.fr>
 <3313d759-917a-e052-787b-ae6755385736@xs4all.nl>
 <E724E143-A498-4345-BEFB-768939EDF232@free.fr>
 <25af7325-829b-6bb7-9d20-09a8db8a7c3d@xs4all.nl>
 <E9F3792B-3D14-48B2-AB45-81E1105402E3@free.fr>
Message-ID: <CAG5iGsDypeqZkEEd30+cHNAEGLq20PEbJc=gx0wWJeXSG7+0xg@mail.gmail.com>

On Tue, Aug 3, 2021 at 3:26 PM jfbu <jfbu at free.fr> wrote:

>
> ah very interesting. I was also very surprised that the Lua solution
> appeared so slow relatively.
>
> Notice by the way that the first Python solution is also very slow...
> slower than my tex one! (to be fair, slower than my ? wheel ? one, but
> Python uses the ? base ? algorithm)
>
>

it seems that you have missed the luajit variant of luatex....

-- 
luigi
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://tug.org/pipermail/luatex/attachments/20210803/7edd64e5/attachment-0001.html>

From j.hagen at xs4all.nl  Tue Aug  3 19:10:13 2021
From: j.hagen at xs4all.nl (Hans Hagen)
Date: Tue, 3 Aug 2021 19:10:13 +0200
Subject: [luatex] how many bytes for fontdimens?
In-Reply-To: <E9F3792B-3D14-48B2-AB45-81E1105402E3@free.fr>
References: <4655BAD2-CA3D-496A-9423-5B6718FBAB13@free.fr>
 <B3909FA6-8DB2-4691-9D63-9D21D3D3A4F9@free.fr>
 <3313d759-917a-e052-787b-ae6755385736@xs4all.nl>
 <E724E143-A498-4345-BEFB-768939EDF232@free.fr>
 <25af7325-829b-6bb7-9d20-09a8db8a7c3d@xs4all.nl>
 <E9F3792B-3D14-48B2-AB45-81E1105402E3@free.fr>
Message-ID: <c8a64cba-c132-08aa-8a9f-c68f1af87651@xs4all.nl>

On 8/3/2021 3:26 PM, jfbu wrote:

>> Le 3 ao?t 2021 ? 12:49, Hans Hagen <j.hagen at xs4all.nl> a ?crit :
>>
>> On 8/3/2021 9:45 AM, jfbu wrote:
>>> Hi,
>>>> Le 3 ao?t 2021 ? 09:09, Hans Hagen <j.hagen at xs4all.nl <mailto:j.hagen at xs4all.nl>> a ?crit :
>>>>
>>>> On 8/2/2021 9:37 PM, jfbu wrote:
>>>>> forgot to mention that I am aware a \fontdimen is limited to 2**30 strictly anyhow
>>>>> but my question is whether such ? arrays ? are stored 32bits or 64bits itemwise
>>>> it happens to be an array of 32 bit integers (that grows on demand) but such implementaiton details are unspecified (could as well have been a sparse array in which case each entry that is actually set has more
>>>>
>>>> also, the fact that it grow is a sort of side effect of the fact that tfm fonts can have 7 or more, but 7 are used, for text upto more for math fonts
>>>>
>>>> so, i wouldn't rely on these properties too much
>>> Thanks!
>>> Reason I asked is because I contributed an Eratosthenes Prime sieve to a github site comparing a whole bunch of langages and it is asked there to specify whether the ? arrays ? use 1bit, 8bits, 32bits, or 64bits (or ? unknown ?) per (potential) prime.
>>> https://github.com/PlummersSoftwareLLC/Primes/blob/drag-race/CONTRIBUTING.md#flag-storage <https://github.com/PlummersSoftwareLLC/Primes/blob/drag-race/CONTRIBUTING.md#flag-storage>
>>
>> ha, i've seen that one a few weeks ago (after some yt video) and to be honnest it's one of these useless speed comparisons (can be fun, but useless as one compares languages with different objectives and doing some prime stuff is hardly representative for usage)
> 
> 
> It seems the C++ solutions listed as fastest do quite a part of the job at compile time not at execution time...

that's why comparing script languages and compiled ones makes no sense 
(one can argue for jit but in e.g. luatex that doesn't pay of)

> The chosen topic (basic sieve and possibly some refinements like ? wheel ? algorithms) seems to test the capacity of the language to access successive memory addresses in the most efficient way and/or perhaps to move bit patterns around.

but that is not made clear -)

> Also, it stops at having the array done, but does not address how you use this after the fact.

indeed

> If the final aim is to print out primes to a file the bottleneck may be rather into the conversion of the bit pattern into explicit ascii bytes...

then lua might perform better because it's all about strings (although 
printing numbers is a bad example as they all differ here)

> For example, if I produce using lualatex a pdf file of all primes less than 999,999,999, most of the time by far is consumed by the typesetting phase (something like 1350 pages, 10 columns per page)

sure because quite some processing kicks in there (fonts, backend, 
columnization) but also the way that big array gets serialized

but 1350 pages for 999.999.999 is not that bad because here 10.000.000 
in 12 columns and an 8pt monospaced font takes 955 pages and indeed some 
runtime (using context that is, latex is supposed to be faster)

> This is what I do except for one auxiliary array in the ? wheel ? because I felt it would be cheating to allocate the 480 slots to start with. I could however have allocated say 1155 = 2310/2 (2310 = 2 * 3 * 5 * 7 *11) slots, wasting some.

even in lua you'd waste them and if oen goes hash there is more overhead 
(linked list) than in an array

> But this is executed only once anyhow, at loading time of the ? sieve library ? independently of the number of passes done during benchmark. Maybe I will do the change for some small gain.
> 
>>> I will thus modify the ? bit count ? tag of my ? solution ? from unknown to 32bits, thanks to your answer, knowing though that this remains officially unspecified. But the Dockerfile which I was asked to include, and which their benchmarking uses, pulls a texlive-minimal based image dating back to 2018.
>>> Perhaps someone here will be interested into contributing a genuine luatex (i.e. using Lua) solution (my code uses only Knuth TeX; there is also a LaTeX3 code also on the github site).
>>
>> a lua solution in luatex is just a lua solution -)
>>
>>> There is already at least one Lua contribution. I don?t know if a genuine luatex would have to be categorized under ? PrimeTeX ? or ? PrimeLua ? ...
>>> ... in particular a LuaTeX genuine solution may have a way to use an ? array ? not based on font dimension parameters.
>>
>> mixing lua and tex will also introduce lua call overhead so there is no gain there (maybe let lua do the sqrt but then you can well do all in lua)
>>
>> my guess is that the sqrt is the bottleneck
>>
>> fontdimens are actually bnto that slow not that slow because they are (1) global so no save stack overhead, and (2) directly accessible because they are part of the font structure (so no tex dimen access overhead)
>>
>> also, using etex \dimexpr is also slower than the simple operators
> 
> Not to mention that etex division rounds which sometimes is more inconvenient than truncating

(it's why in luametatex we have : for integer division, but that's 
another story)

> On the other hand having \numexpr at once disposal allows to more easily have some namespacing of auxiliary counters, using macros instead of \count's

hm. a bit expansive, \chardefs etc are cheaper

>>> One particular point I don?t know is whether LuaTeX would allow a ? faithful ? solution: this seems to mean roughly a class-encapsulated one (it is hard to understand what they precisely mean in their guidelines), which I could not really emulate in my code due to global nature of fontdimen assignments.
>>
>> hm, do you really need local?
> 
> honestly I don?t know exactly what they are aiming at, but I guess basically some piece of code you can re-use in arbitrary code as a library. Global is perhaps not that bad, but having no way to release the memory disqualifies it for faithfulness I believe. The memory can be marked for re-use, but one can not extend the array size after the fact.

font memory is never released anyway

> anyway, at least some namespace should be added to my solution, I did it (weirdly) for some aspects but not all

>> if you use csnames, then you can also consider using \chardef's for numbers (these obey grouping)
> 
> ok, the extended range of \char in luatex would indeed help if one needed to store numbers up to the sieving range of 1,000,000. I have some alternative algorithm needing this kind of storage, but a priori when I mentioned csnames it was only to code a ? on/off ? situation (testing if some number has been marked for composite or no via an \ifcsname, using e-TeX for convenience). Unfortunately this has the overhead of requiring to convert a number into explicit digit tokens.

there is of course a limit in the size of the hash table that you can hit

> or is there a way in luatex to tag objects by numbers not having been converted to digit tokens?

not in luatex

>>> (I also experimented with  a csname based approach but never could reach comparable speed to fontdimen arrays ; and this required extending other parts of the memory)
>>
>> in luatex csname is costly because of the serialization (pdftex is probably faster because there is no utf related overhead)
> 
> I did not compare the two. For the fontdimen based approach, at first pdftex looks faster but on closer look for ranges higher than 1,000,000, it seems luatex gets relatively faster, regarding the process of sieving itself.

hm, maybe hash misses kick in which means a chain lokup (maybe be faster 
in luatex than in pdftex)

> For example I get this typically on my (slow) machine for sieving up to 100,000,000:
> 
> pdftex
> 
> Instantiate object for sieving up to 100000000...
> ...done (0.2322s)
> Sieving...
> ...done (29.4603s)
> Outputting to file listofprimes-100000000.txt...
> 5761455 primes were written to file listofprimes-100000000.txt
> ...done (22.96228s)
>   ) )
> No pages of output.
> Transcript written on wheel_primestofile.log.
> 
> real	0m52.898s
> user	0m52.502s
> sys	0m0.281s
> 
> luatex
> Instantiate object for sieving up to 100000000...
> ...done (3.84619s)
> Sieving...
> ...done (26.5682s)
> Outputting to file listofprimes-100000000.txt...
> 5761455 primes were written to file listofprimes-100000000.txt
> ...done (28.48254s)
> ))
> warning  (pdf backend): no pages of output.
> Transcript written on wheel_primestofile.log.
> 
> real	0m59.444s
> user	0m58.895s
> sys	0m0.445s
> 
> 
> The sieving itself seems being done faster by luatex. For some reason the ? write to file ? part appears slower. As  the ? write to a file ? was not part of benchmark, I simply issue one \write per prime and it is quite possible gathering together the \write?s by batches could improve.  Not tested.

could be because there is some utf juggling but it shoul dnot make a 
huge dent

> Something I don?t understand is that the spread between the ? base ? algorithm (basically the elementary school one, but using only odd numbers from the start, and maybe starting at factor*factor and going by steps of 2*factor) and the ? wheel ? algorithm (with some primes already sieved out) seems to be greater with pdftex than with luatex: perhaps 2.8 or 2.9 speed gain for pdftex, but only like 2.3 or at most 2.5 with luatex.

hard to say ... maybe cpu cache (different programs, different code)

>>> Here is a link to how the various implementations sort out currently on one specific machine:
>>> https://plummerssoftwarellc.github.io/PrimeView/?sc=dt&sd=True&rc=30 <https://plummerssoftwarellc.github.io/PrimeView/?sc=dt&sd=True&rc=30>
>> the lua solution they post is not only somewhat slow but also makes some (imo wrong, but who am i to claim) assumptions about how lua stores data so it was not that hard to make a variant that was over 200 times faster
> 
> ah very interesting. I was also very surprised that the Lua solution appeared so slow relatively.

the latets version posted there is already better but i'll mail you an 
variant of that that is about three times faster

- basic performance        : 1.90
- make functions local     : 1.84
- inline the two functions : 1.52
- use integer division     : 1.27
- some more                : 0.71

> Notice by the way that the first Python solution is also very slow... slower than my tex one! (to be fair, slower than my ? wheel ? one, but Python uses the ? base ? algorithm)

object oriented pverhead i guess (the few times that i ran into some 
python code it was easy to make faster lua variants)

>> because i have a relative old laptop i can't compare with the numbers for e.g. c there (of course lua will be slower)
> 
> I think the machine they use for the ? PrimeView ? is also relatively old (2013). Mine is 2012 and is faster than theirs.
> 
>> but as i consider these shootouts useles anyway, i didn't want to spend more time on it (all that docker stuff and such)
> 
> I confirm I have spent between 5x and 10x more time with these contributing requirements than with the TeX coding itself. In the end the Dockerfile is very simple but it went through more complicated intermediate versions. I did not want to pull a 4G or 5G texlive image though and initially I was using pdftex but needed to understand how to let it acquire more memory, then I used luatex but I needed to add \pdfresettimer, which finally I did via the \directlua in the tex file itself.
> 
>> nor comment on the posted lua code (i never comment on code anyway, unless I know someone well and we can discuss specific issues out of mutual interest)
> 
> This is wise indeed.
> 
> I know some under-optimal aspects of my contribution and I have not tested some aspects like whether at some location I should use \ifdim rather than \ifnum, or even some other way of testing. I also hesitated regarding the wheel algorithm between using only one giant array, or 480 smaller ones indexed on class modulo 2310, the latter approach reducing the memory impact (by a factor of 1155/480).

it looked at the code but it will take me too much time to check where 
it can be made faster (saw a few spots) as i have to make sieve only 
macro then

> Also let me point out that during the various squashes before my PR was merged, I accidentally lost crediting the fact that the \Replicate I use, copied over from xint with removal of e-TeX, was originally basically cloned from the LaTeX3 and has a decades old history I trust.

dunno, loops can be very fast when done right (and when on eknows where 
tex's bottlenecks are -)

> I have also not tried to optimise how this \Replicate should be used, deciding to nest it with an inner one replicating 1000 times, but never testing if that was actually good.  As the benchmarking overthere is done only for 1,000,000 range, there is danger also to make code seemingly general but in fact tailored for that range only, which would not be entirely fair, imho.

maybe don't pass the number but put it in a register ; this romannumeral 
is also kind of strange (not sure why you need it ; actually you should 
time romannumeral in pdftex vs luatex .. could be more efficient in 
thelater

>> (messing with bits and storing efficiently in lua probably costs more than it saves, and the same might be true in tex)
> 
> Sadly, the nice coincidence that TeX dimensions allow 30 bits and that 30=2*3*5 does not help much as I know no native TeX way to do bitwise operations. We only need two: setting a bit and querying it. This can de done with existing TeX arithmetic and/or macros but will be costly. I did not even try it out.

this is off topic but in luametatex we can do

\scratchcounter 1

\scratchcounter \numexpression \scratchcounter bor 4\relax

\the\scratchcounter : 5

which performs quite ok (1 milion times takes .27 sec on my machine)

> I also know of no way to initialize a \fontdimen array of a specific size with a specific pattern such as  some non-zero dimension repeated all the way, apart naturally to go through assigning all of them one by one, where the fact that always the same value is used brings no gain whatsoever.
ok, but when you pack bits you do 32 per stel so you migth end up in the 
'seconds' range

i'll mail you my test file

Hans

-----------------------------------------------------------------
                                           Hans Hagen | PRAGMA ADE
               Ridderstraat 27 | 8061 GH Hasselt | The Netherlands
        tel: 038 477 53 69 | www.pragma-ade.nl | www.pragma-pod.nl
-----------------------------------------------------------------

From jfbu at free.fr  Tue Aug  3 20:57:54 2021
From: jfbu at free.fr (jfbu)
Date: Tue, 3 Aug 2021 20:57:54 +0200
Subject: [luatex] how many bytes for fontdimens?
In-Reply-To: <c8a64cba-c132-08aa-8a9f-c68f1af87651@xs4all.nl>
References: <4655BAD2-CA3D-496A-9423-5B6718FBAB13@free.fr>
 <B3909FA6-8DB2-4691-9D63-9D21D3D3A4F9@free.fr>
 <3313d759-917a-e052-787b-ae6755385736@xs4all.nl>
 <E724E143-A498-4345-BEFB-768939EDF232@free.fr>
 <25af7325-829b-6bb7-9d20-09a8db8a7c3d@xs4all.nl>
 <E9F3792B-3D14-48B2-AB45-81E1105402E3@free.fr>
 <c8a64cba-c132-08aa-8a9f-c68f1af87651@xs4all.nl>
Message-ID: <803006FF-3E0F-4B03-B6AB-D54346A2486B@free.fr>



> Le 3 ao?t 2021 ? 19:10, Hans Hagen <j.hagen at xs4all.nl> a ?crit :
> 
> but 1350 pages for 999.999.999 is not that bad because here 10.000.000 in 12 columns and an 8pt monospaced font takes 955 pages and indeed some runtime (using context that is, latex is supposed to be faster)

Hi, only to clarify I have wrongly mentioned 999,999,999 in place of ...much much smaller 10,000,000. 

It is for primes < 10,000,000 that my LaTeX multicols template produced a pdf of 1357 pages, 10 columns per page, primes from top to bottom.

(and in a private mail to you I said 100,000,000 which was again wrong, sorry for all the confusion...)

The pages are produced at a rythme of about 20 pages per second on my machine.

I launched it for 999,999,999 but CTRL-Ced it after about 16,000 pages, realizing that it would grow to probably about 100,000 pages and take for this more than one hour (this is only typesetting phase, producing a text file with the primes took about 10mns).

[16813] [16814] [16815] [16816] [16817] [16818^C]
! Interruption.
<argument> ...hipout_box \__shipout_drop_firstpage_specials: 
                                                  \set at typeset@protect \hook...

l.8240836 1
         46169809
? X
 68117 words of node memory still in use:
   1021 hlist, 14 vlist, 10 rule, 506 local_par, 1 dir, 2532 glue, 4 kern, 505 
penalty, 4551 glyph, 1042 attribute, 63 glue_spec, 1042 attribute_list, 2 temp,
 1 if_stack nodes
   avail lists: 1:1,2:8,3:493,4:1,5:14,6:490,7:6873,9:1010
</usr/local/texlive/2020/texmf-dist/fonts/opentype/public/lm/lmroman10-regular.
otf>
Output written on wheel_primestopdf_v.pdf (16818 pages, 63100748 bytes).
Transcript written on wheel_primestopdf_v.log.

real	14m30.727s
user	14m12.666s
sys	0m6.963s


The last included prime was146,169,497

This run was done with the primes already available in an external input ? text ? file (one prime per line). This external file of circa 500Mo costed last week about 10mn30s to produce on my machine (old 2Ghz ) (about 6mns to compute the prime fontdimen array, and about 5mns to convert it into the file with explicit digits).

The above interrupted PDF opens in my pdf viewerafter a somewhat longish wait... and I sadly discover on page 11759 that once primes exceed 100,000,000, they overlap due to there not being enough rooms in the columns. As I did not adujst appropriately the page margins...

Anyway, nice that I could CTRL-C the lualatex job and get a working pdf. 
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://tug.org/pipermail/luatex/attachments/20210803/00614070/attachment.html>

From jfbu at free.fr  Thu Aug  5 09:50:06 2021
From: jfbu at free.fr (jfbu)
Date: Thu, 5 Aug 2021 09:50:06 +0200
Subject: [luatex] how many bytes for fontdimens?
In-Reply-To: <c8a64cba-c132-08aa-8a9f-c68f1af87651@xs4all.nl>
References: <4655BAD2-CA3D-496A-9423-5B6718FBAB13@free.fr>
 <B3909FA6-8DB2-4691-9D63-9D21D3D3A4F9@free.fr>
 <3313d759-917a-e052-787b-ae6755385736@xs4all.nl>
 <E724E143-A498-4345-BEFB-768939EDF232@free.fr>
 <25af7325-829b-6bb7-9d20-09a8db8a7c3d@xs4all.nl>
 <E9F3792B-3D14-48B2-AB45-81E1105402E3@free.fr>
 <c8a64cba-c132-08aa-8a9f-c68f1af87651@xs4all.nl>
Message-ID: <E6FCBDA7-2F3C-4463-922C-14E4844F6AC0@free.fr>

Hi,

replying on-list on one topic, as this will be relatively brief (off-list material at start but last topic is luatex related):

> Le 3 ao?t 2021 ? 19:10, Hans Hagen <j.hagen at xs4all.nl> a ?crit :
> 
>> I have also not tried to optimise how this \Replicate should be used, deciding to nest it with an inner one replicating 1000 times, but never testing if that was actually good.  [...]
> 
> maybe don't pass the number but put it in a register ;

first thing that the macro does anyhow is to make sure it handles explicit digits, the original used \the\numexpr and this version sticks to Knuth and has a reduced interface requiring user to call it with explicit digits or with ? \the\somecount ? so a single \expandafter does the job.

And in inner inner loops, only a variant doing hard-coded 1000 repetitions is used and has no argument

> this romannumeral is also kind of strange (not sure why you need it

you are absolutely right. It serves nothing in this context. The original is from an area where I provide most macros in two forms say ? \Foo ? and ? \foo ? where \Foo expands to \romannumeral\foo (to be precise rather \romannumeral0\foo due to legacy reasons of relative ignorance 8 years ago, but here for this replicate, it is indeed \romanumeral\foo). This means you can do \expandafter\Stuff\romannumeral\foo rather than \expandafter\expandafter\expandafter\Stuff\Foo.

In the case at hand the core expansion is anyhow \csname governed and one could re-organize stuff so that \Foo would be \csname\foo rather, with some micro gain. But this would have been at odds with the style in the original codebase from which it is extracted.

In this specific usage, definitely I could drop the \romannumeral and the paired closing \z at . Will keep this in mind when I will review sieve code for small improvements.

> ; actually you should time romannumeral in pdftex vs luatex .. could be more efficient in thelater

The \romannumeral in my context (sic) are only there to trigger and end expansion... I needed to scratch a bit my head to benchmark that in a way allowing to compare pdftex vs luatex, and I am not sure I do it right. But here we go, typical results on my hardware are listed below and are... surprising to me.

-------- START OF TEST FILE
\long\def\Lots#1{\Repx{\Repm{#1}}}% 10000
\long\def\Repm#1{\Repc{#1#1#1#1#1#1#1#1#1#1}}
\long\def\Repc#1{\Repx{#1#1#1#1#1#1#1#1#1#1}}
\long\def\Repx#1{#1#1#1#1#1#1#1#1#1#1}

\ifdefined\directlua
% copied from https://tex.stackexchange.com/a/32531
  \directlua{pdfelapsedtimer_basetime=0}%
  \def\pdfresettimer{\directlua{pdfelapsedtimer_basetime = os.clock()}}%
  \def\pdfelapsedtime{\numexpr\directlua{tex.print(math.floor((os.clock()-pdfelapsedtimer_basetime)*65536+0.5))}\relax}%
\fi

\catcode`@ 11
%\def\empty{}
%\z@ is a dimen set to 0pt
\let\Tall\z@
\let\Uall\z@

\Repx{%
\immediate\write128{}%
\pdfresettimer
\Lots{\romannumeral\Repm\empty\z@}% 10000 times a r triggered silly expan.
\edef\T{\the\dimexpr\pdfelapsedtime sp}%
\immediate\write128{with: \T}%
\pdfresettimer
\Lots{\Repm\empty}%
\edef\U{\the\dimexpr\pdfelapsedtime sp}%
\immediate\write128{without: \U}%
% update totals
\edef\Tall{\the\dimexpr\Tall+\T}%
\edef\Uall{\the\dimexpr\Uall+\U}%

% always strange things with timer so redo it with order reversed after a \par
\pdfresettimer
\Lots{\Repm\empty}%
\edef\U{\the\dimexpr\pdfelapsedtime sp}%
\immediate\write128{without: \U}%
\pdfresettimer
\Lots{\romannumeral\Repm\empty\z@}% 10000 times a r triggered silly expan.
\edef\T{\the\dimexpr\pdfelapsedtime sp}%
\immediate\write128{with: \T}%

% update totals
\edef\Tall{\the\dimexpr\Tall+\T}%
\edef\Uall{\the\dimexpr\Uall+\U}%
}%

\immediate\write128{}
\immediate\write128{with (total): \Tall}
\immediate\write128{without (total): \Uall}
\immediate\write128{with minus without: \the\dimexpr\Tall-\Uall}
\bye
-------- END OF TEST FILE

% pdftex
with (total): 5.34964pt
without (total): 5.45686pt
with minus without: -0.10722pt

with (total): 5.55394pt
without (total): 5.61536pt
with minus without: -0.06142pt

with (total): 5.35501pt
without (total): 5.3827pt
with minus without: -0.0277pt

% luatex
with (total): 6.08586pt
without (total): 6.30107pt
with minus without: -0.21521pt

with (total): 6.06969pt
without (total): 6.35312pt
with minus without: -0.28343pt

with (total): 6.11238pt
without (total): 6.37778pt
with minus without: -0.2654pt


Conclusion is that it seems to *speed up* ? expanding to empty ? to *add* \romannumeral wrapper.... 

and indeed with luatex the relative gain is even higher than with pdftex... implying \romannumeral is even more efficient there


Kind regards
Jean-Fran?ois
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://tug.org/pipermail/luatex/attachments/20210805/a1dd973e/attachment.html>

From jfbu at free.fr  Thu Aug  5 10:01:18 2021
From: jfbu at free.fr (jfbu)
Date: Thu, 5 Aug 2021 10:01:18 +0200
Subject: [luatex] how many bytes for fontdimens?
In-Reply-To: <E6FCBDA7-2F3C-4463-922C-14E4844F6AC0@free.fr>
References: <4655BAD2-CA3D-496A-9423-5B6718FBAB13@free.fr>
 <B3909FA6-8DB2-4691-9D63-9D21D3D3A4F9@free.fr>
 <3313d759-917a-e052-787b-ae6755385736@xs4all.nl>
 <E724E143-A498-4345-BEFB-768939EDF232@free.fr>
 <25af7325-829b-6bb7-9d20-09a8db8a7c3d@xs4all.nl>
 <E9F3792B-3D14-48B2-AB45-81E1105402E3@free.fr>
 <c8a64cba-c132-08aa-8a9f-c68f1af87651@xs4all.nl>
 <E6FCBDA7-2F3C-4463-922C-14E4844F6AC0@free.fr>
Message-ID: <BC40ADDA-8572-4741-B2EE-69597A997444@free.fr>



> Le 5 ao?t 2021 ? 09:50, jfbu <jfbu at free.fr> a ?crit :
> 
> % pdftex
> with (total): 5.34964pt
> without (total): 5.45686pt
> with minus without: -0.10722pt
> 
> with (total): 5.55394pt
> without (total): 5.61536pt
> with minus without: -0.06142pt
> 
> with (total): 5.35501pt
> without (total): 5.3827pt
> with minus without: -0.0277pt
> 
> % luatex
> with (total): 6.08586pt
> without (total): 6.30107pt
> with minus without: -0.21521pt
> 
> with (total): 6.06969pt
> without (total): 6.35312pt
> with minus without: -0.28343pt
> 
> with (total): 6.11238pt
> without (total): 6.37778pt
> with minus without: -0.2654pt
> 

I had accidentally TEXMFCNF set in my environment (from previous tests).

Testing some more with this environment variable of TeXLive unset, I
get completely different results.

% pdftex
with (total): 5.46095pt
without (total): 5.43422pt
with minus without: 0.02673pt

% luatex
with (total): 6.10898pt
without (total): 6.03908pt
with minus without: 0.0699pt


And re-setting it (to "$(pwd)") I reproduce again typically the above results...

i.e. with TEXMFCNF set its is advantageous to use \romannumeral,
both with pdftex and with luatex.

with TEXMFCNF not set, it is disadvantageous...

... that?s highly baffling to me !

I repeated quite a few times to make sure timings are consistent,
it seems with luatex it is, with pdftex less so 

ok, I don?t want to induce people to lose time on ill-conceived test

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://tug.org/pipermail/luatex/attachments/20210805/45e7b852/attachment.html>

From jfbu at free.fr  Thu Aug  5 10:04:10 2021
From: jfbu at free.fr (jfbu)
Date: Thu, 5 Aug 2021 10:04:10 +0200
Subject: [luatex] how many bytes for fontdimens?
In-Reply-To: <BC40ADDA-8572-4741-B2EE-69597A997444@free.fr>
References: <4655BAD2-CA3D-496A-9423-5B6718FBAB13@free.fr>
 <B3909FA6-8DB2-4691-9D63-9D21D3D3A4F9@free.fr>
 <3313d759-917a-e052-787b-ae6755385736@xs4all.nl>
 <E724E143-A498-4345-BEFB-768939EDF232@free.fr>
 <25af7325-829b-6bb7-9d20-09a8db8a7c3d@xs4all.nl>
 <E9F3792B-3D14-48B2-AB45-81E1105402E3@free.fr>
 <c8a64cba-c132-08aa-8a9f-c68f1af87651@xs4all.nl>
 <E6FCBDA7-2F3C-4463-922C-14E4844F6AC0@free.fr>
 <BC40ADDA-8572-4741-B2EE-69597A997444@free.fr>
Message-ID: <74A0E990-6A23-4F41-915F-969380CD7995@free.fr>



> Le 5 ao?t 2021 ? 10:01, jfbu <jfbu at free.fr> a ?crit :
> 
> And re-setting it (to "$(pwd)") I reproduce again typically the above results...
> 


"$(pwd):"

error due to fighting with my Mail converting straight quotes into curly quotes
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://tug.org/pipermail/luatex/attachments/20210805/1da4ea7e/attachment.html>

From j.hagen at xs4all.nl  Thu Aug  5 11:25:13 2021
From: j.hagen at xs4all.nl (Hans Hagen)
Date: Thu, 5 Aug 2021 11:25:13 +0200
Subject: [luatex] how many bytes for fontdimens?
In-Reply-To: <BC40ADDA-8572-4741-B2EE-69597A997444@free.fr>
References: <4655BAD2-CA3D-496A-9423-5B6718FBAB13@free.fr>
 <B3909FA6-8DB2-4691-9D63-9D21D3D3A4F9@free.fr>
 <3313d759-917a-e052-787b-ae6755385736@xs4all.nl>
 <E724E143-A498-4345-BEFB-768939EDF232@free.fr>
 <25af7325-829b-6bb7-9d20-09a8db8a7c3d@xs4all.nl>
 <E9F3792B-3D14-48B2-AB45-81E1105402E3@free.fr>
 <c8a64cba-c132-08aa-8a9f-c68f1af87651@xs4all.nl>
 <E6FCBDA7-2F3C-4463-922C-14E4844F6AC0@free.fr>
 <BC40ADDA-8572-4741-B2EE-69597A997444@free.fr>
Message-ID: <c731dc8a-5c4d-bb03-5bc5-3f46ab30073c@xs4all.nl>

On 8/5/2021 10:01 AM, jfbu wrote:
> 
> 
>> Le 5 ao?t 2021 ? 09:50, jfbu <jfbu at free.fr <mailto:jfbu at free.fr>> a 
>> ?crit :
>>
>> % pdftex
>> with (total): 5.34964pt
>> without (total): 5.45686pt
>> with minus without: -0.10722pt
>>
>> with (total): 5.55394pt
>> without (total): 5.61536pt
>> with minus without: -0.06142pt
>>
>> with (total): 5.35501pt
>> without (total): 5.3827pt
>> with minus without: -0.0277pt
>>
>> % luatex
>> with (total): 6.08586pt
>> without (total): 6.30107pt
>> with minus without: -0.21521pt
>>
>> with (total): 6.06969pt
>> without (total): 6.35312pt
>> with minus without: -0.28343pt
>>
>> with (total): 6.11238pt
>> without (total): 6.37778pt
>> with minus without: -0.2654pt
>>
> 
> I had accidentally TEXMFCNF set in my environment (from previous tests).
> 
> Testing some more with this environment variable of TeXLive unset, I
> get completely different results.
> 
> % pdftex
> with (total): 5.46095pt
> without (total): 5.43422pt
> with minus without: 0.02673pt
> 
> % luatex
> with (total): 6.10898pt
> without (total): 6.03908pt
> with minus without: 0.0699pt
> 
> 
> And re-setting it (to "$(pwd)") I reproduce again typically the above 
> results...
> 
> i.e. with TEXMFCNF set its is advantageous to use \romannumeral,
> both with pdftex and with luatex.
> 
> with TEXMFCNF not set, it is disadvantageous...
> 
> ... that?s highly baffling to me !
> 
> I repeated quite a few times to make sure timings are consistent,
> it seems with luatex it is, with pdftex less so
> 
> ok, I don?t want to induce people to lose time on ill-conceived test

one thinkg that you need to keep in mind is the size of the texmf tree

in context we don't use kpse so we don't suffer much from the size of 
the tree (it was actually oen of the first thing i did in mkiv/luatex, 
some 15 years ago: replace kpse with a lua variant)

when you use kpse (pdftex, luatex etc with latex) these lsr files are 
loaded and hashed, that takes time

then, when you add a local tree (e.g. home) that one gets scanned every run

so, in a tex live setup: the more files, the longer the start up time

a context installation (from the garden) is rather small compared to 
texlive, and an lmtx installation even smaller (most is documentation 
and fonts) .. over the year i've spend a lot of time making the user 
experience such that on the average a run is ok (on my 2013 laptop lmtx 
start up time is < .5 sec which includes dealing with all (some) 500 lua 
modules

i have no clue about latex overhead as i never run that (one of the 
persistent naratives is that latex is way faster than context but i'm 
not really sure about that)

most tex performance test are rubish ... one can test "test\par" or 
"test\page" a thousand times but what does it say ...

\starttext \testfeatureonce{1000}{test\par} \stoptext

system          > feature test done: 1000 steps, 0.090 seconds, 
0.000089939 per step
mkiv lua stats  > runtime: 0.542 seconds, 25 processed pages, 25 shipped 
pages, 46.125 pages/second


\starttext \testfeatureonce{10000}{test\par} \stoptext

system          > feature test done: 10000 steps, 0.907 seconds, 
0.000090726 per step
mkiv lua stats  > runtime: 1.370 seconds, 244 processed pages, 244 
shipped pages, 178.067 pages/second

\starttext \testfeatureonce{10000}{\null\page} \stoptext

system          > feature test done: 10000 steps, 12.509 seconds, 
0.001250932 per step
mkiv lua stats  > runtime: 13.487 seconds, 10000 processed pages, 10000 
shipped pages, 741.441 pages/second

\starttext \testfeatureonce{1000}{\samplefile{tufte}\page} \stoptext

system          > feature test done: 1000 steps, 4.290 seconds, 
0.004290208 per step
mkiv lua stats  > runtime: 4.815 seconds, 1000 processed pages, 1000 
shipped pages, 207.703 pages/second

now all this is not realistic: kick in some color, fonts, graphics, 
advanced structuring and in the end 20-30 pps is what one gets

(maybe on a modern machine twice that)

add some tikz and one can drink a coffee

in the end using an ssd, more memory (caching) had more impact than cpu 
bosts

(ok, i made the luametatex mem footprint much smaller than the luatex 
one but that's more for raspbery pi and such ... on that we run some 3 
times slower than on my intel laptop .. more a pet project)

Hans


-----------------------------------------------------------------
                                           Hans Hagen | PRAGMA ADE
               Ridderstraat 27 | 8061 GH Hasselt | The Netherlands
        tel: 038 477 53 69 | www.pragma-ade.nl | www.pragma-pod.nl
-----------------------------------------------------------------

From reinhard.kotucha at web.de  Fri Aug  6 03:23:04 2021
From: reinhard.kotucha at web.de (Reinhard Kotucha)
Date: Fri, 6 Aug 2021 03:23:04 +0200
Subject: [luatex] how many bytes for fontdimens?
In-Reply-To: <BC40ADDA-8572-4741-B2EE-69597A997444@free.fr>
References: <4655BAD2-CA3D-496A-9423-5B6718FBAB13@free.fr>
 <B3909FA6-8DB2-4691-9D63-9D21D3D3A4F9@free.fr>
 <3313d759-917a-e052-787b-ae6755385736@xs4all.nl>
 <E724E143-A498-4345-BEFB-768939EDF232@free.fr>
 <25af7325-829b-6bb7-9d20-09a8db8a7c3d@xs4all.nl>
 <E9F3792B-3D14-48B2-AB45-81E1105402E3@free.fr>
 <c8a64cba-c132-08aa-8a9f-c68f1af87651@xs4all.nl>
 <E6FCBDA7-2F3C-4463-922C-14E4844F6AC0@free.fr>
 <BC40ADDA-8572-4741-B2EE-69597A997444@free.fr>
Message-ID: <24844.36600.696530.985544@gargle.gargle.HOWL>

On 2021-08-05 at 10:01:18 +0200, jfbu wrote:

 > I had accidentally TEXMFCNF set in my environment (from previous tests).
 > 
 > Testing some more with this environment variable of TeXLive unset, I
 > get completely different results.

Hello Jean-Fran?ois,
as Hans already pointed out, the size of the texmf tree matters.  IMO
it's not a good idea to change TeX Live's configuration.  You can't
achieve a significant improvement this way.  And please avoid
TeX-related environment variables whenever possible.

If you run

  svn co https://svnrepo.ddns.net/tinytex

and copy the file ./tinytex/trunk/tinytex to /usr/local/bin then you
can precede the command line with tinytex, for instance

  tinytex luatex somefile.tex

This will create a directory tinytex.d in your current working
directory containing a minimal TeX Live installation which contains
only the files needed in order to compile your document.

tinytex is cumulative.  This means that if you run

  tinytex bibtex ...

the required files will be added to the tinytex.d directory.

Only files installed within the current TeX Live tree (that one which
is found in PATH) are copied to tinytex.d.

If you run

  tinytex --shell

a shell script tinytex.sh is created in your working directory which
starts a new shell with ./tinytex.d/bin/<platform> prepended to PATH.
You can leave this enviromnent with exit as usual.

Please note that any TeX Live related environment variable can confuse
tinytex too.  It's always best to avoid them.

I wrote this script about ten years ago and used it for several
projects.  There is no other documentation than --help.

tinytex is based on strace(1) and thus runs only on Unix.  But it's
possible to add binaries for other platforms, even Windows, if you
create a configuration file.  The binaries for all desired platforms
must be installed on your system.  If some are missing, run

  tlmgr platform add ...

Windows is a bit problematic.  Because there are no symlinks the
*tex.exe files are only stubs which load shared libraries containing
the actual code.  In order to locate these libraries I examine the
.exe files with strings(1).  It always worked for me so far but I
can't guarantee that it always works.

Regarding kpathsea and the creation of hashes, as mentioned by Hans,
it makes a difference whether there are 20 or 200,000 files.  If only
a few files are present it doesn't matter which algorithm is used to
locate them.  And tinytex creates the smallest possible TeX Live
system for a particular project.


Other things to consider are format files.  When I've set up

  http://metar.ddns.net

I noticed that the plain TeX format file contained all the stuff from
unicode.org which is currently only used by LaTeX3, AFAIK.  So I
created my own format file with the unicode stuff omitted and a few
things added which otherwise had to be done at runtime.

It's sufficient to create a customized format file in the current
working directory.  

Especially if you are using LaTeX it makes sense to to put as much as
possible into the format file instead of loading all the files at
runtime.

Regards,
  Reinhard

-- 
------------------------------------------------------------------
Reinhard Kotucha                            Phone: +49-511-3373112
Marschnerstr. 25
D-30167 Hannover                    mailto:reinhard.kotucha at web.de
------------------------------------------------------------------


From j.hagen at xs4all.nl  Sat Aug  7 10:39:36 2021
From: j.hagen at xs4all.nl (Hans Hagen)
Date: Sat, 7 Aug 2021 10:39:36 +0200
Subject: [luatex] how many bytes for fontdimens?
In-Reply-To: <24844.36600.696530.985544@gargle.gargle.HOWL>
References: <4655BAD2-CA3D-496A-9423-5B6718FBAB13@free.fr>
 <B3909FA6-8DB2-4691-9D63-9D21D3D3A4F9@free.fr>
 <3313d759-917a-e052-787b-ae6755385736@xs4all.nl>
 <E724E143-A498-4345-BEFB-768939EDF232@free.fr>
 <25af7325-829b-6bb7-9d20-09a8db8a7c3d@xs4all.nl>
 <E9F3792B-3D14-48B2-AB45-81E1105402E3@free.fr>
 <c8a64cba-c132-08aa-8a9f-c68f1af87651@xs4all.nl>
 <E6FCBDA7-2F3C-4463-922C-14E4844F6AC0@free.fr>
 <BC40ADDA-8572-4741-B2EE-69597A997444@free.fr>
 <24844.36600.696530.985544@gargle.gargle.HOWL>
Message-ID: <23eb86d2-cf62-1fe5-e8f4-c3d4a0177b27@xs4all.nl>

On 8/6/2021 3:23 AM, Reinhard Kotucha wrote:
> On 2021-08-05 at 10:01:18 +0200, jfbu wrote:
> 
>   > I had accidentally TEXMFCNF set in my environment (from previous tests).
>   >
>   > Testing some more with this environment variable of TeXLive unset, I
>   > get completely different results.
> 
> Hello Jean-Fran?ois,
> as Hans already pointed out, the size of the texmf tree matters.  IMO
> it's not a good idea to change TeX Live's configuration.  You can't
> achieve a significant improvement this way.  And please avoid
> TeX-related environment variables whenever possible.
of course with ssd's and plenty of memory (so the OS can cache lost of 
files) things became less an issue the last decade

Hans

-----------------------------------------------------------------
                                           Hans Hagen | PRAGMA ADE
               Ridderstraat 27 | 8061 GH Hasselt | The Netherlands
        tel: 038 477 53 69 | www.pragma-ade.nl | www.pragma-pod.nl
-----------------------------------------------------------------

From jfbu at free.fr  Sun Aug  8 19:22:52 2021
From: jfbu at free.fr (jfbu)
Date: Sun, 8 Aug 2021 19:22:52 +0200
Subject: [luatex]  how many bytes for fontdimens?
Message-ID: <D29D95D8-D4A6-4883-9C64-4741152EB7DC@free.fr>

Hi Reinhard,

I belatedly (as I don?t subscribe yet) see your informative post on the luatex mailing list,

I did not know about tinytex and will look into it thanks for the pointer!

About

> Hello Jean-Fran?ois,
> as Hans already pointed out, the size of the texmf tree matters.  IMO
> it's not a good idea to change TeX Live's configuration.  You can't
> achieve a significant improvement this way.  And please avoid
> TeX-related environment variables whenever possible.


it was needed to set TEXMFCNF
in my original testing in order to enlarge texlive?s font_mem_size
parameter for pdftex usage, as

- the -cnf-line option (recognized by TL2021 pdftex binary) is not recognized
  by the pdftex from (the Docker image based on) TL2018 minimal scheme

  (i.e. I can?t do this

  pdftex -cnf-line "font_mem_size=147483647" erato_benchmark

  which TeXLive 2018)

and

- with the help of a texmf.cnf
  file in the working repertory dictating the font_mem_size setting,
  exporting to the environment TEXMFCNF="(pwd):" lets pdftex use
  the maximally (147483647 words) enlarged font memory


I usually did this encapsulated in a script, but sometimes did

export TEXMFCNF="(pwd):"

on the command line and forgot to reset the environment afterwards.
(by the way, context users will be quickly reminded of this oversight from the
mtxrun          | unknown script 'context.lua' or 'mtx-context.lua?
error message when TEXMFCNF is set as above)

This led me to realize (??) that there was (or not), sometimes, 
some effect
on a seemingly quite unrelated matter on whether to use or not
a (serving to nothing) \romannumeral inside a \Replicate

[digression: this \Replicate comes from my xintkernel.sty where the \romannumeral was
justified by other things, among them presence of an added layer using
\numexpr which I removed because I wanted the prime sieve
to use only Knuth tex; I could have used \csname not \romannumeral
actually even with this \numexpr. I had modeled some years back 
the xintkernel.sty Replicate on latex3 code with
some changes including not raising an error if used with
negative argument]

But this whole thing is disconcerting: evidence and truth are
utterly evident? ?but do change radically at unexpected
times it appears.

I have made enough noise, now attaching my benchmark file which
has some desperate comments in case some foolish person is interested
into running luatex with it

I am going to have very limited internet access for most of August,
starting tomorrow,
 <strike>so posting this off-list as anyhow I can?t follow</strike>
posting on-list after all

PS, some additional and final off-topic noise:

since my initial post to the luatex list I have updated
my sieve code at 

https://github.com/PlummersSoftwareLLC/Primes/tree/drag-race/PrimeTeX/solution_2

The main change was to replace =1sp<space> assignments into =\onesp
with \onesp a \dimen with value 1sp, I knew naturally this would bring some gain,
but it is spectacular for the base sieve 
with pdftex it was almost 3X speed gain from this change only! (on the sieving part isolated).

A further change on advice from Hans, was to use \ifcase in place of \ifdim\foo=\z@,
which proves definitely beneficial too (but for some much smaller gain)

Another change bringing a small improvement
was to use systematically = in \count and \dimen assignments

(in the wheel algorithm there is still an inefficiency about using one \count
assignment too many in the loop, but I am leaving it as it as the maintainers
of the above site are a bit overworked from successive PRs)

Cheers,

Jean-Fran?ois

-------------- next part --------------
A non-text attachment was scrubbed...
Name: testromannumeral.tex
Type: application/octet-stream
Size: 7010 bytes
Desc: not available
URL: <https://tug.org/pipermail/luatex/attachments/20210808/98f9d713/attachment.obj>
-------------- next part --------------



From witiko at mail.muni.cz  Sun Aug 29 00:43:23 2021
From: witiko at mail.muni.cz (=?utf-8?B?VsOtdGVrIE5vdm90bsO9?=)
Date: Sun, 29 Aug 2021 00:43:23 +0200
Subject: [luatex] Adding a callback before trailing spaces are removed from
 a line of input
Message-ID: <20210828224322.vuuzmyln5rimeo4n@inspiron>

Hello all,

in Knuth's TeX, trailing spaces are removed very early on when a line is
being put to the input buffer. [1]  According to Eijkhout's TeX by
Topic, this is because "these spaces are hard to see in an editor" [2].

 [1]: https://texdoc.org/serve/tex.pdf/0#page=15
 [2]: http://mirrors.ctan.org/info/texbytopic/TeXbyTopic.pdf

I develop and maintain the Markdown package [3] for plain TeX, ConTeXt,
and LaTeX. The package makes it possible to use the lightweight markup
of markdown [4] in TeX documents. In markdown, a hard line break can be
inserted by ending a line with two or more spaces. However, since
trailing spaces are removed by TeX, hard breaks are only recognized when
we' are inserting an external markdown file, not when markdown is typed
in the top-level document. This deficiency is known and documented [5],
but I am hoping we could resolve it with LuaTeX.

 [3]: https://github.com/witiko/markdown
 [4]: https://daringfireball.net/projects/markdown
 [5]: https://mirrors.ctan.org/macros/generic/markdown/markdown.pdf#page=20

In LuaTeX, the `process_input_buffer` callback [6] can be used to
intercept the text coming *out* of the input buffer. However, the
trailing spaces have already been removed by this point.

By adding a callback right after a line has entered the input buffer
[1], we could either replace the trailing space characters with tabs,
or place a character such as the zero-width non-joiner (U+200C) to the
right of the trailing spaces.

 [6]: https://www.pragma-ade.com/general/manuals/luatex.pdf#page=176

Is this something you would consider---if not for LuaTeX then perhaps
for LuaMetaTeX?

Best regards,
V?tek Novotn?
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <https://tug.org/pipermail/luatex/attachments/20210829/1c1f79bc/attachment.sig>

From j.hagen at xs4all.nl  Sun Aug 29 12:11:44 2021
From: j.hagen at xs4all.nl (Hans Hagen)
Date: Sun, 29 Aug 2021 12:11:44 +0200
Subject: [luatex] Adding a callback before trailing spaces are removed
 from a line of input
In-Reply-To: <20210828224322.vuuzmyln5rimeo4n@inspiron>
References: <20210828224322.vuuzmyln5rimeo4n@inspiron>
Message-ID: <6e1377e9-ec0f-53a3-eda5-ae5721615570@xs4all.nl>

On 8/29/2021 12:43 AM, V?tek Novotn? wrote:
> Hello all,
> 
> in Knuth's TeX, trailing spaces are removed very early on when a line is
> being put to the input buffer. [1]  According to Eijkhout's TeX by
> Topic, this is because "these spaces are hard to see in an editor" [2].
> 
>   [1]: https://texdoc.org/serve/tex.pdf/0#page=15
>   [2]: http://mirrors.ctan.org/info/texbytopic/TeXbyTopic.pdf
> 
> I develop and maintain the Markdown package [3] for plain TeX, ConTeXt,
> and LaTeX. The package makes it possible to use the lightweight markup
> of markdown [4] in TeX documents. In markdown, a hard line break can be
> inserted by ending a line with two or more spaces. However, since
> trailing spaces are removed by TeX, hard breaks are only recognized when
> we' are inserting an external markdown file, not when markdown is typed
> in the top-level document. This deficiency is known and documented [5],
> but I am hoping we could resolve it with LuaTeX.

i wonder how this double spaces works out in practice, for instance one 
needs to 'visualize' them in the editor so see them and also make sure 
that the editor is not in 'prune space at the end of line' mode

>   [3]: https://github.com/witiko/markdown
>   [4]: https://daringfireball.net/projects/markdown
>   [5]: https://mirrors.ctan.org/macros/generic/markdown/markdown.pdf#page=20
> 
> In LuaTeX, the `process_input_buffer` callback [6] can be used to
> intercept the text coming *out* of the input buffer. However, the
> trailing spaces have already been removed by this point.
> 
> By adding a callback right after a line has entered the input buffer
> [1], we could either replace the trailing space characters with tabs,
> or place a character such as the zero-width non-joiner (U+200C) to the
> right of the trailing spaces.

i fear that this will introduce a performance hit

>   [6]: https://www.pragma-ade.com/general/manuals/luatex.pdf#page=176
> 
> Is this something you would consider---if not for LuaTeX then perhaps
> for LuaMetaTeX?
for a while i had a endofline handler but removed it because i never 
used it as it made no sense (it's all too unpredictable) so i removed it
(i wanted to backport it but it doesn't really fit in now that luatex 
also has some special \par handling added)

concerning context, how is \startmarkdown defined? I'm pretty sure that 
this issue can handled without adding callbacks (i never needed/use(d) 
markdown myself so i can only guess here) but we can discuss the needs 
off-luatex-list

Hans


-----------------------------------------------------------------
                                           Hans Hagen | PRAGMA ADE
               Ridderstraat 27 | 8061 GH Hasselt | The Netherlands
        tel: 038 477 53 69 | www.pragma-ade.nl | www.pragma-pod.nl
-----------------------------------------------------------------

From eduardoochs at gmail.com  Sun Aug 29 13:03:47 2021
From: eduardoochs at gmail.com (Eduardo Ochs)
Date: Sun, 29 Aug 2021 08:03:47 -0300
Subject: [luatex] Adding a callback before trailing spaces are removed
 from a line of input
In-Reply-To: <20210828224322.vuuzmyln5rimeo4n@inspiron>
References: <20210828224322.vuuzmyln5rimeo4n@inspiron>
Message-ID: <CADs++6jiZHOuZgEqiZTOZRrS46D7r9RK5MgrWkZka3p0QyDZPA@mail.gmail.com>

Hi Vitek,

I am the author of this package,

  http://angg.twu.net/dednat6/tug-slides.pdf
  http://angg.twu.net/dednat6/tugboat-rev2.pdf
  http://angg.twu.net/dednat6.html

that uses Lua to read material from the _comments_ of the current .tex
file. I think that what you need can be implemented easily on top of
this single-file version of the core of dednat6,

  http://angg.twu.net/dednat6/dednat6/minimalcore.lua.html
  http://angg.twu.net/dednat6/dednat6/minimalcore.lua
  http://angg.twu.net/dednat6/demo-core.tex.html
  http://angg.twu.net/dednat6/demo-core.tex
  http://angg.twu.net/dednat6/demo-core.pdf

that only implements the code that interprets each block of lines
starting with "%L" as a chunk of Lua code...

If this looks interesting to you, please get in touch! I took a
quick look at your markdown.dtx and I got the impression that 1) it
would be trivial to make my minimalcore.lua read the markdown code in
fencedCode blocks and make TeX skip over it, and that 2) it would be
easy to port the ideas from the prototype made with minimalcore.lua to
your markdown package.

  Cheers,
    Eduardo Ochs
    http://angg.twu.net/contact.html



On Sat, 28 Aug 2021 at 19:57, V?tek Novotn? <witiko at mail.muni.cz> wrote:

> Hello all,
>
> in Knuth's TeX, trailing spaces are removed very early on when a line is
> being put to the input buffer. [1]  According to Eijkhout's TeX by
> Topic, this is because "these spaces are hard to see in an editor" [2].
>
>  [1]: https://texdoc.org/serve/tex.pdf/0#page=15
>  [2]: http://mirrors.ctan.org/info/texbytopic/TeXbyTopic.pdf
>
> I develop and maintain the Markdown package [3] for plain TeX, ConTeXt,
> and LaTeX. The package makes it possible to use the lightweight markup
> of markdown [4] in TeX documents. In markdown, a hard line break can be
> inserted by ending a line with two or more spaces. However, since
> trailing spaces are removed by TeX, hard breaks are only recognized when
> we' are inserting an external markdown file, not when markdown is typed
> in the top-level document. This deficiency is known and documented [5],
> but I am hoping we could resolve it with LuaTeX.
>
>  [3]: https://github.com/witiko/markdown
>  [4]: https://daringfireball.net/projects/markdown
>  [5]:
> https://mirrors.ctan.org/macros/generic/markdown/markdown.pdf#page=20
>
> In LuaTeX, the `process_input_buffer` callback [6] can be used to
> intercept the text coming *out* of the input buffer. However, the
> trailing spaces have already been removed by this point.
>
> By adding a callback right after a line has entered the input buffer
> [1], we could either replace the trailing space characters with tabs,
> or place a character such as the zero-width non-joiner (U+200C) to the
> right of the trailing spaces.
>
>  [6]: https://www.pragma-ade.com/general/manuals/luatex.pdf#page=176
>
> Is this something you would consider---if not for LuaTeX then perhaps
> for LuaMetaTeX?
>
> Best regards,
> V?tek Novotn?
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://tug.org/pipermail/luatex/attachments/20210829/063a74bb/attachment.html>

From witiko at mail.muni.cz  Sun Aug 29 17:57:49 2021
From: witiko at mail.muni.cz (=?utf-8?B?VsOtdGVrIE5vdm90bsO9?=)
Date: Sun, 29 Aug 2021 17:57:49 +0200
Subject: [luatex] Adding a callback before trailing spaces are removed
 from a line of input
In-Reply-To: <CADs++6jiZHOuZgEqiZTOZRrS46D7r9RK5MgrWkZka3p0QyDZPA@mail.gmail.com>
References: <20210828224322.vuuzmyln5rimeo4n@inspiron>
 <CADs++6jiZHOuZgEqiZTOZRrS46D7r9RK5MgrWkZka3p0QyDZPA@mail.gmail.com>
Message-ID: <20210829155749.wxueurgslux4c3ce@inspiron>

On Sun, Aug 29, 2021 at 08:03:47AM -0300, Eduardo Ochs wrote:
> Hi Vitek,
> 
> I am the author of this package,
> 
>   http://angg.twu.net/dednat6/tug-slides.pdf
>   http://angg.twu.net/dednat6/tugboat-rev2.pdf
>   http://angg.twu.net/dednat6.html

Dear Eduardo,

thank you for your response. What a beautiful package: ASCII art
diagrams translated to production-quality outputs?! Sold! Perhaps we
should write an article about using markdown and friends to produce
academic texts using easy-to-read-and-write domain-specific languages.

> that uses Lua to read material from the _comments_ of the current .tex
> file. I think that what you need can be implemented easily on top of
> this single-file version of the core of dednat6,
> 
>   http://angg.twu.net/dednat6/dednat6/minimalcore.lua.html
>   http://angg.twu.net/dednat6/dednat6/minimalcore.lua
>   http://angg.twu.net/dednat6/demo-core.tex.html
>   http://angg.twu.net/dednat6/demo-core.tex
>   http://angg.twu.net/dednat6/demo-core.pdf
> 
> that only implements the code that interprets each block of lines
> starting with "%L" as a chunk of Lua code...
> 
> If this looks interesting to you, please get in touch! I took a
> quick look at your markdown.dtx and I got the impression that 1) it
> would be trivial to make my minimalcore.lua read the markdown code in
> fencedCode blocks and make TeX skip over it, and that 2) it would be
> easy to port the ideas from the prototype made with minimalcore.lua to
> your markdown package.

Using an external program to preprocess a TeX document is an interesting
approach, but one that doesn't seem compatible with the way the Markdown
package has operated for the past five years: we buffer input inside an
environment, and we pass it to the Lua parser. We definitely don't want
to use comments to separate Markdown text from the rest of the document:
That can be justified for short ASCII art diagrams, but sounds pretty
user-hostile for, say, a book worth of markdown text.

>   Cheers,
>     Eduardo Ochs
>     http://angg.twu.net/contact.html

Best,
V?tek

> On Sat, 28 Aug 2021 at 19:57, V?tek Novotn? <witiko at mail.muni.cz> wrote:
> 
> > Hello all,
> >
> > in Knuth's TeX, trailing spaces are removed very early on when a line is
> > being put to the input buffer. [1]  According to Eijkhout's TeX by
> > Topic, this is because "these spaces are hard to see in an editor" [2].
> >
> >  [1]: https://texdoc.org/serve/tex.pdf/0#page=15
> >  [2]: http://mirrors.ctan.org/info/texbytopic/TeXbyTopic.pdf
> >
> > I develop and maintain the Markdown package [3] for plain TeX, ConTeXt,
> > and LaTeX. The package makes it possible to use the lightweight markup
> > of markdown [4] in TeX documents. In markdown, a hard line break can be
> > inserted by ending a line with two or more spaces. However, since
> > trailing spaces are removed by TeX, hard breaks are only recognized when
> > we' are inserting an external markdown file, not when markdown is typed
> > in the top-level document. This deficiency is known and documented [5],
> > but I am hoping we could resolve it with LuaTeX.
> >
> >  [3]: https://github.com/witiko/markdown
> >  [4]: https://daringfireball.net/projects/markdown
> >  [5]:
> > https://mirrors.ctan.org/macros/generic/markdown/markdown.pdf#page=20
> >
> > In LuaTeX, the `process_input_buffer` callback [6] can be used to
> > intercept the text coming *out* of the input buffer. However, the
> > trailing spaces have already been removed by this point.
> >
> > By adding a callback right after a line has entered the input buffer
> > [1], we could either replace the trailing space characters with tabs,
> > or place a character such as the zero-width non-joiner (U+200C) to the
> > right of the trailing spaces.
> >
> >  [6]: https://www.pragma-ade.com/general/manuals/luatex.pdf#page=176
> >
> > Is this something you would consider---if not for LuaTeX then perhaps
> > for LuaMetaTeX?
> >
> > Best regards,
> > V?tek Novotn?
> >
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <https://tug.org/pipermail/luatex/attachments/20210829/dfeeee6c/attachment-0001.sig>

From witiko at mail.muni.cz  Sun Aug 29 18:38:05 2021
From: witiko at mail.muni.cz (=?utf-8?B?VsOtdGVrIE5vdm90bsO9?=)
Date: Sun, 29 Aug 2021 18:38:05 +0200
Subject: [luatex] Adding a callback before trailing spaces are removed
 from a line of input
In-Reply-To: <6e1377e9-ec0f-53a3-eda5-ae5721615570@xs4all.nl>
References: <20210828224322.vuuzmyln5rimeo4n@inspiron>
 <6e1377e9-ec0f-53a3-eda5-ae5721615570@xs4all.nl>
Message-ID: <20210829163805.l2e2yuzoj4rh4kty@inspiron>

On Sun, Aug 29, 2021 at 12:11:44PM +0200, Hans Hagen wrote:
> On 8/29/2021 12:43 AM, V?tek Novotn? wrote:
> > Hello all,
> > 
> > in Knuth's TeX, trailing spaces are removed very early on when a line is
> > being put to the input buffer. [1]  According to Eijkhout's TeX by
> > Topic, this is because "these spaces are hard to see in an editor" [2].
> > 
> >   [1]: https://texdoc.org/serve/tex.pdf/0#page=15
> >   [2]: http://mirrors.ctan.org/info/texbytopic/TeXbyTopic.pdf
> > 
> > I develop and maintain the Markdown package [3] for plain TeX, ConTeXt,
> > and LaTeX. The package makes it possible to use the lightweight markup
> > of markdown [4] in TeX documents. In markdown, a hard line break can be
> > inserted by ending a line with two or more spaces. However, since
> > trailing spaces are removed by TeX, hard breaks are only recognized when
> > we' are inserting an external markdown file, not when markdown is typed
> > in the top-level document. This deficiency is known and documented [5],
> > but I am hoping we could resolve it with LuaTeX.
> 
> i wonder how this double spaces works out in practice, for instance one
> needs to 'visualize' them in the editor so see them and also make sure that
> the editor is not in 'prune space at the end of line' mode

Dear Hans,

thank you for your response. To visualize trailing spaces in Vim, I have
these three lines at the bottom of my ~/.vimrc:

    """ Highlight trailing spaces
    highlight TrailingSpaces ctermbg=red guibg=red
    match TrailingSpaces /\s\+$/

In my experience, most editors don't automatically prune trailing
spaces. If yours does, you can separate markdown to an external
document, and set up your text editor to behave differently for TeX
files and markdown files.

> >   [3]: https://github.com/witiko/markdown
> >   [4]: https://daringfireball.net/projects/markdown
> >   [5]: https://mirrors.ctan.org/macros/generic/markdown/markdown.pdf#page=20
> > 
> > In LuaTeX, the `process_input_buffer` callback [6] can be used to
> > intercept the text coming *out* of the input buffer. However, the
> > trailing spaces have already been removed by this point.
> > 
> > By adding a callback right after a line has entered the input buffer
> > [1], we could either replace the trailing space characters with tabs,
> > or place a character such as the zero-width non-joiner (U+200C) to the
> > right of the trailing spaces.
> 
> i fear that this will introduce a performance hit

Hopefully negligible when there are no registered callbacks.

> >   [6]: https://www.pragma-ade.com/general/manuals/luatex.pdf#page=176
> > 
> > Is this something you would consider---if not for LuaTeX then perhaps
> > for LuaMetaTeX?
>
> for a while i had a endofline handler but removed it because i never used it
> as it made no sense (it's all too unpredictable) so i removed it
> (i wanted to backport it but it doesn't really fit in now that luatex also
> has some special \par handling added)
> 
> concerning context, how is \startmarkdown defined? I'm pretty sure that this
> issue can handled without adding callbacks

We implement \startmarkdown in terms of the \markdownReadAndConvert [7]
plain TeX macro, which scans and buffers the input using TeX. We don't
use ConTeXt buffers for consistency, since the implementation of
\markdownReadAndConvert is shared between the plain TeX, LaTeX, and
ConTeXt Markdown packages. We don't use Lua to buffer the input for
compatibility with non-Lua TeX engines.

 [7]: https://github.com/Witiko/markdown/blob/main/markdown.dtx#L18070

We could use the ConTeXt buffers [8] to define \startmarkdown, but these
too gobble the trailing spaces, so this does not improve the status quo.

 [8]: https://wiki.contextgarden.net/Command/startbuffer

> (i never needed/use(d) markdown myself so i can only guess here) but
> we can discuss the needs off-luatex-list

And yet, you are included in the copyright line of the Markdown package,
since you contributed to the lunamark parser:

    $ docker run --rm -i witiko/markdown markdown-cli -v
    markdown-cli.lua (Markdown) 2.10.0-64-ge9b5180
    Copyright (C) 2009-2016 John MacFarlane, Hans Hagen
    Copyright (C) 2016-2021 V?t Novotn?
    License: LPPL 1.3c

> Hans

Best,
V?tek

> -----------------------------------------------------------------
>                                           Hans Hagen | PRAGMA ADE
>               Ridderstraat 27 | 8061 GH Hasselt | The Netherlands
>        tel: 038 477 53 69 | www.pragma-ade.nl | www.pragma-pod.nl
> -----------------------------------------------------------------
> 
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <https://tug.org/pipermail/luatex/attachments/20210829/4a552cc9/attachment-0001.sig>

From eduardoochs at gmail.com  Sun Aug 29 21:01:17 2021
From: eduardoochs at gmail.com (Eduardo Ochs)
Date: Sun, 29 Aug 2021 16:01:17 -0300
Subject: [luatex] Adding a callback before trailing spaces are removed
 from a line of input
In-Reply-To: <20210829155749.wxueurgslux4c3ce@inspiron>
References: <20210828224322.vuuzmyln5rimeo4n@inspiron>
 <CADs++6jiZHOuZgEqiZTOZRrS46D7r9RK5MgrWkZka3p0QyDZPA@mail.gmail.com>
 <20210829155749.wxueurgslux4c3ce@inspiron>
Message-ID: <CADs++6jXW9=QeYZu69y+QDN772S7ZTe5cRG2hyPnM8NWEk-JFg@mail.gmail.com>

Hi V?tek,

the first prototype is here:

  https://github.com/edrx/markdown-dednat6/

The main part of test.tex is the one that contains:

  \directlua{Foo("End of block")}
  Plop
   Plip

    Bletch
  End of block

The \directlua{Foo("End of block")} prints the lines before "End of
block" to stdout with line numbers, and you should get this on stdout:

  39:     "Plop"
  40:     " Plip"
  41:     "   "
  42:     "  Bletch"

but I don't remember how to make luatex skip the next 5 lines of
input.. how can we do that? I need that for the second prototype, to
convince you that we can use that to parse Markdown... =)

  Cheers,
    Eduardo Ochs
    http://angg.twu.net/dednat6.html


On Sun, 29 Aug 2021 at 12:57, V?tek Novotn? <witiko at mail.muni.cz> wrote:

> On Sun, Aug 29, 2021 at 08:03:47AM -0300, Eduardo Ochs wrote:
> > Hi Vitek,
> >
> > I am the author of this package,
> >
> >   http://angg.twu.net/dednat6/tug-slides.pdf
> >   http://angg.twu.net/dednat6/tugboat-rev2.pdf
> >   http://angg.twu.net/dednat6.html
>
> Dear Eduardo,
>
> thank you for your response. What a beautiful package: ASCII art
> diagrams translated to production-quality outputs?! Sold! Perhaps we
> should write an article about using markdown and friends to produce
> academic texts using easy-to-read-and-write domain-specific languages.
>
> > that uses Lua to read material from the _comments_ of the current .tex
> > file. I think that what you need can be implemented easily on top of
> > this single-file version of the core of dednat6,
> >
> >   http://angg.twu.net/dednat6/dednat6/minimalcore.lua.html
> >   http://angg.twu.net/dednat6/dednat6/minimalcore.lua
> >   http://angg.twu.net/dednat6/demo-core.tex.html
> >   http://angg.twu.net/dednat6/demo-core.tex
> >   http://angg.twu.net/dednat6/demo-core.pdf
> >
> > that only implements the code that interprets each block of lines
> > starting with "%L" as a chunk of Lua code...
> >
> > If this looks interesting to you, please get in touch! I took a
> > quick look at your markdown.dtx and I got the impression that 1) it
> > would be trivial to make my minimalcore.lua read the markdown code in
> > fencedCode blocks and make TeX skip over it, and that 2) it would be
> > easy to port the ideas from the prototype made with minimalcore.lua to
> > your markdown package.
>
> Using an external program to preprocess a TeX document is an interesting
> approach, but one that doesn't seem compatible with the way the Markdown
> package has operated for the past five years: we buffer input inside an
> environment, and we pass it to the Lua parser. We definitely don't want
> to use comments to separate Markdown text from the rest of the document:
> That can be justified for short ASCII art diagrams, but sounds pretty
> user-hostile for, say, a book worth of markdown text.
>
> >   Cheers,
> >     Eduardo Ochs
> >     http://angg.twu.net/contact.html
>
> Best,
> V?tek
>
> > On Sat, 28 Aug 2021 at 19:57, V?tek Novotn? <witiko at mail.muni.cz> wrote:
> >
> > > Hello all,
> > >
> > > in Knuth's TeX, trailing spaces are removed very early on when a line
> is
> > > being put to the input buffer. [1]  According to Eijkhout's TeX by
> > > Topic, this is because "these spaces are hard to see in an editor" [2].
> > >
> > >  [1]: https://texdoc.org/serve/tex.pdf/0#page=15
> > >  [2]: http://mirrors.ctan.org/info/texbytopic/TeXbyTopic.pdf
> > >
> > > I develop and maintain the Markdown package [3] for plain TeX, ConTeXt,
> > > and LaTeX. The package makes it possible to use the lightweight markup
> > > of markdown [4] in TeX documents. In markdown, a hard line break can be
> > > inserted by ending a line with two or more spaces. However, since
> > > trailing spaces are removed by TeX, hard breaks are only recognized
> when
> > > we' are inserting an external markdown file, not when markdown is typed
> > > in the top-level document. This deficiency is known and documented [5],
> > > but I am hoping we could resolve it with LuaTeX.
> > >
> > >  [3]: https://github.com/witiko/markdown
> > >  [4]: https://daringfireball.net/projects/markdown
> > >  [5]:
> > > https://mirrors.ctan.org/macros/generic/markdown/markdown.pdf#page=20
> > >
> > > In LuaTeX, the `process_input_buffer` callback [6] can be used to
> > > intercept the text coming *out* of the input buffer. However, the
> > > trailing spaces have already been removed by this point.
> > >
> > > By adding a callback right after a line has entered the input buffer
> > > [1], we could either replace the trailing space characters with tabs,
> > > or place a character such as the zero-width non-joiner (U+200C) to the
> > > right of the trailing spaces.
> > >
> > >  [6]: https://www.pragma-ade.com/general/manuals/luatex.pdf#page=176
> > >
> > > Is this something you would consider---if not for LuaTeX then perhaps
> > > for LuaMetaTeX?
> > >
> > > Best regards,
> > > V?tek Novotn?
> > >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://tug.org/pipermail/luatex/attachments/20210829/35ae42fb/attachment.html>

From witiko at mail.muni.cz  Sun Aug 29 21:42:00 2021
From: witiko at mail.muni.cz (=?utf-8?B?VsOtdGVrIE5vdm90bsO9?=)
Date: Sun, 29 Aug 2021 21:42:00 +0200
Subject: [luatex] Adding a callback before trailing spaces are removed
 from a line of input
In-Reply-To: <CADs++6jXW9=QeYZu69y+QDN772S7ZTe5cRG2hyPnM8NWEk-JFg@mail.gmail.com>
References: <20210828224322.vuuzmyln5rimeo4n@inspiron>
 <CADs++6jiZHOuZgEqiZTOZRrS46D7r9RK5MgrWkZka3p0QyDZPA@mail.gmail.com>
 <20210829155749.wxueurgslux4c3ce@inspiron>
 <CADs++6jXW9=QeYZu69y+QDN772S7ZTe5cRG2hyPnM8NWEk-JFg@mail.gmail.com>
Message-ID: <20210829194200.w7t4icidhqbxmyod@inspiron>

Dear Eduardo,

ah, light begins to shine! I suppose you could register a
process_line_buffer callback, which would `return ""` until it has
matched "End of block" or until it has been called five times, at which
point it would unregister itself.

Either way, this seems to be a solution. It's not a clean solution in
the sense that we have to read the TeX document twice, assuming that
it has not been altered in between, but it is a solution that we can
use today.

Thank you!
V?tek

On Sun, Aug 29, 2021 at 04:01:17PM -0300, Eduardo Ochs wrote:
> Hi V?tek,
> 
> the first prototype is here:
> 
>   https://github.com/edrx/markdown-dednat6/
> 
> The main part of test.tex is the one that contains:
> 
>   \directlua{Foo("End of block")}
>   Plop
>    Plip
> 
>     Bletch
>   End of block
> 
> The \directlua{Foo("End of block")} prints the lines before "End of
> block" to stdout with line numbers, and you should get this on stdout:
> 
>   39:     "Plop"
>   40:     " Plip"
>   41:     "   "
>   42:     "  Bletch"
> 
> but I don't remember how to make luatex skip the next 5 lines of
> input.. how can we do that? I need that for the second prototype, to
> convince you that we can use that to parse Markdown... =)
> 
>   Cheers,
>     Eduardo Ochs
>     http://angg.twu.net/dednat6.html
> 
> 
> On Sun, 29 Aug 2021 at 12:57, V?tek Novotn? <witiko at mail.muni.cz> wrote:
> 
> > On Sun, Aug 29, 2021 at 08:03:47AM -0300, Eduardo Ochs wrote:
> > > Hi Vitek,
> > >
> > > I am the author of this package,
> > >
> > >   http://angg.twu.net/dednat6/tug-slides.pdf
> > >   http://angg.twu.net/dednat6/tugboat-rev2.pdf
> > >   http://angg.twu.net/dednat6.html
> >
> > Dear Eduardo,
> >
> > thank you for your response. What a beautiful package: ASCII art
> > diagrams translated to production-quality outputs?! Sold! Perhaps we
> > should write an article about using markdown and friends to produce
> > academic texts using easy-to-read-and-write domain-specific languages.
> >
> > > that uses Lua to read material from the _comments_ of the current .tex
> > > file. I think that what you need can be implemented easily on top of
> > > this single-file version of the core of dednat6,
> > >
> > >   http://angg.twu.net/dednat6/dednat6/minimalcore.lua.html
> > >   http://angg.twu.net/dednat6/dednat6/minimalcore.lua
> > >   http://angg.twu.net/dednat6/demo-core.tex.html
> > >   http://angg.twu.net/dednat6/demo-core.tex
> > >   http://angg.twu.net/dednat6/demo-core.pdf
> > >
> > > that only implements the code that interprets each block of lines
> > > starting with "%L" as a chunk of Lua code...
> > >
> > > If this looks interesting to you, please get in touch! I took a
> > > quick look at your markdown.dtx and I got the impression that 1) it
> > > would be trivial to make my minimalcore.lua read the markdown code in
> > > fencedCode blocks and make TeX skip over it, and that 2) it would be
> > > easy to port the ideas from the prototype made with minimalcore.lua to
> > > your markdown package.
> >
> > Using an external program to preprocess a TeX document is an interesting
> > approach, but one that doesn't seem compatible with the way the Markdown
> > package has operated for the past five years: we buffer input inside an
> > environment, and we pass it to the Lua parser. We definitely don't want
> > to use comments to separate Markdown text from the rest of the document:
> > That can be justified for short ASCII art diagrams, but sounds pretty
> > user-hostile for, say, a book worth of markdown text.
> >
> > >   Cheers,
> > >     Eduardo Ochs
> > >     http://angg.twu.net/contact.html
> >
> > Best,
> > V?tek
> >
> > > On Sat, 28 Aug 2021 at 19:57, V?tek Novotn? <witiko at mail.muni.cz> wrote:
> > >
> > > > Hello all,
> > > >
> > > > in Knuth's TeX, trailing spaces are removed very early on when a line
> > is
> > > > being put to the input buffer. [1]  According to Eijkhout's TeX by
> > > > Topic, this is because "these spaces are hard to see in an editor" [2].
> > > >
> > > >  [1]: https://texdoc.org/serve/tex.pdf/0#page=15
> > > >  [2]: http://mirrors.ctan.org/info/texbytopic/TeXbyTopic.pdf
> > > >
> > > > I develop and maintain the Markdown package [3] for plain TeX, ConTeXt,
> > > > and LaTeX. The package makes it possible to use the lightweight markup
> > > > of markdown [4] in TeX documents. In markdown, a hard line break can be
> > > > inserted by ending a line with two or more spaces. However, since
> > > > trailing spaces are removed by TeX, hard breaks are only recognized
> > when
> > > > we' are inserting an external markdown file, not when markdown is typed
> > > > in the top-level document. This deficiency is known and documented [5],
> > > > but I am hoping we could resolve it with LuaTeX.
> > > >
> > > >  [3]: https://github.com/witiko/markdown
> > > >  [4]: https://daringfireball.net/projects/markdown
> > > >  [5]:
> > > > https://mirrors.ctan.org/macros/generic/markdown/markdown.pdf#page=20
> > > >
> > > > In LuaTeX, the `process_input_buffer` callback [6] can be used to
> > > > intercept the text coming *out* of the input buffer. However, the
> > > > trailing spaces have already been removed by this point.
> > > >
> > > > By adding a callback right after a line has entered the input buffer
> > > > [1], we could either replace the trailing space characters with tabs,
> > > > or place a character such as the zero-width non-joiner (U+200C) to the
> > > > right of the trailing spaces.
> > > >
> > > >  [6]: https://www.pragma-ade.com/general/manuals/luatex.pdf#page=176
> > > >
> > > > Is this something you would consider---if not for LuaTeX then perhaps
> > > > for LuaMetaTeX?
> > > >
> > > > Best regards,
> > > > V?tek Novotn?
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <https://tug.org/pipermail/luatex/attachments/20210829/badc7f21/attachment.sig>

From j.hagen at xs4all.nl  Sun Aug 29 22:43:38 2021
From: j.hagen at xs4all.nl (Hans Hagen)
Date: Sun, 29 Aug 2021 22:43:38 +0200
Subject: [luatex] Adding a callback before trailing spaces are removed
 from a line of input
In-Reply-To: <20210829163805.l2e2yuzoj4rh4kty@inspiron>
References: <20210828224322.vuuzmyln5rimeo4n@inspiron>
 <6e1377e9-ec0f-53a3-eda5-ae5721615570@xs4all.nl>
 <20210829163805.l2e2yuzoj4rh4kty@inspiron>
Message-ID: <f530a30f-15dc-af86-8c88-aa88f19ec1f2@xs4all.nl>

On 8/29/2021 6:38 PM, V?tek Novotn? wrote:

> And yet, you are included in the copyright line of the Markdown package,
> since you contributed to the lunamark parser:
> 
>      $ docker run --rm -i witiko/markdown markdown-cli -v
>      markdown-cli.lua (Markdown) 2.10.0-64-ge9b5180
>      Copyright (C) 2009-2016 John MacFarlane, Hans Hagen
>      Copyright (C) 2016-2021 V?t Novotn?
>      License: LPPL 1.3c
sure, i remember that i helped make that one faster and more efficient; 
i probabloy have some code laying around from when i looked into it but 
when simethign is supporte din conetxt that doesn't mean i'm a user 
myself (probably most of what i add to context etc is not used by 
myself, it's often about challenges and fun)

Hans

-----------------------------------------------------------------
                                           Hans Hagen | PRAGMA ADE
               Ridderstraat 27 | 8061 GH Hasselt | The Netherlands
        tel: 038 477 53 69 | www.pragma-ade.nl | www.pragma-pod.nl
-----------------------------------------------------------------

From eduardoochs at gmail.com  Sun Aug 29 23:40:46 2021
From: eduardoochs at gmail.com (Eduardo Ochs)
Date: Sun, 29 Aug 2021 18:40:46 -0300
Subject: [luatex] Adding a callback before trailing spaces are removed
 from a line of input
In-Reply-To: <20210829194200.w7t4icidhqbxmyod@inspiron>
References: <20210828224322.vuuzmyln5rimeo4n@inspiron>
 <CADs++6jiZHOuZgEqiZTOZRrS46D7r9RK5MgrWkZka3p0QyDZPA@mail.gmail.com>
 <20210829155749.wxueurgslux4c3ce@inspiron>
 <CADs++6jXW9=QeYZu69y+QDN772S7ZTe5cRG2hyPnM8NWEk-JFg@mail.gmail.com>
 <20210829194200.w7t4icidhqbxmyod@inspiron>
Message-ID: <CADs++6idf_9UYe7V8ULZiqeU-xGMT=0chLa-45FrQ+ojy7rQ+w@mail.gmail.com>

On Sun, 29 Aug 2021 at 16:42, V?tek Novotn? <witiko at mail.muni.cz> wrote:

> Dear Eduardo,
>
> ah, light begins to shine! I suppose you could register a
> process_line_buffer callback, which would `return ""` until it has
> matched "End of block" or until it has been called five times, at which
> point it would unregister itself.
>
>
Hi Vitek,

I've just uploaded the second prototype to github - in this one when
we call Foo with a second arguments, like this,

  \directlua{Foo("End of block", "skip")}

it skips the lines that are fake Markdown by making
"process_input_buffer" return "%". It is here,

  https://github.com/edrx/markdown-dednat6/

and its test.tex file is just this, plus comments:

--snip--snip--

\documentclass{article}
\begin{document}

\catcode`\^^J=10
\directlua{dofile "minimalcore.lua"}
\directlua{texfile0(status.filename)}
\def\pu{\directlua{pu()}}

%L skiplinesuntil_ = 0
%L skiplinesuntil  = function (li)
%L     if tex.inputlineno <= skiplinesuntil_ then
%L       return "%"
%L     end
%L     return li
%L   end
%L luatexbase.add_to_callback("process_input_buffer",
%L    skiplinesuntil, "skiplinesuntil")
%L
%L findlinewithre = function (firstline, re)
%L     for i=firstline,1000000 do
%L       if texlines[i] == nil then error("re not found") end
%L       if texlines[i]:match(re) then return i end
%L     end
%L   end
%L printlines = function (i, j)
%L     print("\n\n")
%L     for k=i,j do print(k..":", '"'..texlines[k]..'"') end
%L     print("\n\n")
%L   end
%L Foo = function (re, skip)
%L     local outerbeg = tex.inputlineno
%L     local innerbeg = outerbeg + 1
%L     local innerend = findlinewithre(innerbeg, re) - 1
%L     local outerend = innerend + 1
%L     printlines(innerbeg, innerend)
%L     if skip then skiplinesuntil_ = outerend end
%L   end
%L
\pu

(Test 1)
\directlua{Foo("End of block")}%
Plop
 Plip
  Bletch
End of block
(without skip, with \%)

(Test 2)
\directlua{Foo("End of block", "skip")}%
Plop
 Plip
  Bletch
End of block
(with skip, with \%)

(Test 3)
\directlua{Foo("End of block", "skip")}
Plop
 Plip
  Bletch
End of block
(with skip, without \%)

\end{document}

--snip--snip--


When we don't add a "%" after the \directlua line then a strange space
appears, and I don't know why. I also don't know how to handle in an
elegant way the cases in which we have a main .tex file that "\input"s
other .tex files that also have blocks of "%L" lines and blocks of
fake Markdown code... in Dednat6 I handle this by using this quick
hack in each of my sub-.tex files:

  http://angg.twu.net/LATEX/dednat6/block.lua.html#tf_push_and_tf_pop

If you have any ideas for solving this, please let me know!

  Cheers,
    Eduardo Ochs
    http://angg.twu.net/dednat6.html
    http://angg.twu.net/math-b.html
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://tug.org/pipermail/luatex/attachments/20210829/7d47a9e2/attachment-0001.html>

