From unbonpetit at gmail.com  Sun Nov  4 12:38:31 2012
From: unbonpetit at gmail.com (christian)
Date: Sun, 4 Nov 2012 12:38:31 +0100
Subject: [luatex] \hrule misplacement
Message-ID: <509653B7.4040405@gmail.com>

Hi,

when compiling the following mwe with luatex [Version 
beta-0.70.2-2012052410 (TeX Live 2012)], the "foo" word is not in the 
baseline in the pdf output:

%%%%%%%%%%%%%%%%%%
Begining
\vbox{%
     \hbox{myfoobar}%
     \hrule width0pt depth0pt height5pt
     \hbox{foo}%
}
the end.
\bye
%%%%%%%%%%%%%%%%%%

It seems that the \hrule is placed at the bottom of the \vbox instead 
between the \hbox's.
Sorry for the noise if it is a known bug.

Christian

From taco at elvenkind.com  Sun Nov  4 17:13:14 2012
From: taco at elvenkind.com (Taco Hoekwater)
Date: Sun, 4 Nov 2012 17:13:14 +0100
Subject: [luatex] \hrule misplacement
In-Reply-To: <509653B7.4040405@gmail.com>
References: <509653B7.4040405@gmail.com>
Message-ID: <5096941A.30706@elvenkind.com>

On 11/04/2012 12:38 PM, christian wrote:
> Hi,
>
> when compiling the following mwe with luatex [Version
> beta-0.70.2-2012052410 (TeX Live 2012)], the "foo" word is not in the
> baseline in the pdf output:
>
> %%%%%%%%%%%%%%%%%%
> Begining
> \vbox{%
>      \hbox{myfoobar}%
>      \hrule width0pt depth0pt height5pt
>      \hbox{foo}%
> }
> the end.
> \bye
> %%%%%%%%%%%%%%%%%%
>
> It seems that the \hrule is placed at the bottom of the \vbox instead
> between the \hbox's.

Apparently so, it appears to be some kind of problem in the backend
(the internal node list is in the correct order). Hartmut?


Best wishes,
Taco

From Herbert.Voss at FU-Berlin.DE  Sun Nov  4 20:24:45 2012
From: Herbert.Voss at FU-Berlin.DE (Herbert Voss)
Date: Sun, 4 Nov 2012 20:24:45 +0100
Subject: [luatex] problem with a pk font and ngerman
Message-ID: <5096C0FD.5050401@FU-Berlin.DE>

The following example works with pdflatex but not with
lualatex. Here the letter "a" of "Late" is missing.
You need an up-to-date TL2012. Without babel or another language
as ngerman it is also ok. For the test run I deleted everything
in ~/.texlive2012/texmf-var/
I have no idea why ngerman should be a problem with the
letter a. If I write "Lat" then the a is present.


\documentclass{article}

\usepackage[ngerman]{babel}

\begin{document}



\usefont{T1}{wela}{m}{sl}

Late



\end{document}


This is LuaTeX, Version beta-0.70.2-2012052410 (TeX Live 2012)
  \write18 enabled.
(./Namenlos-4.tex
LaTeX2e <2011/06/27>
LuaTeX adaptation of babel <v3.8m-luatex-1.5> and hyphenation patterns 
for engl
ish, dumylang, nohyphenation, loaded.
(/usr/local/texlive/2012/texmf-dist/tex/latex/base/article.cls
Document Class: article 2007/10/19 v1.4h Standard LaTeX document class
(/usr/local/texlive/2012/texmf-dist/tex/latex/base/size10.clo))
(/usr/local/texlive/2012/texmf-dist/tex/generic/babel/babel.sty
(/usr/local/texlive/2012/texmf-dist/tex/generic/babel/ngermanb.ldf
(/usr/local/texlive/2012/texmf-dist/tex/generic/babel/babel.def)))
(./Namenlos-4.aux)
(/usr/local/texlive/2012/texmf-dist/tex/latex/schulschriften/t1wela.fd)
[1{/usr/local/texlive/2012/texmf-var/fonts/map/pdftex/updmap/pdftex.map}]
(./Namenlos-4.aux
kpathsea: Running mktexpk --mfmode / --bdpi 600 --mag 0+429/600 --dpi 
429 welasl14
mktexpk: Running mf-nowin -progname=mf \mode:=ljfour; mag:=0+429/600; 
nonstopmode; input welasl14
This is METAFONT, Version 2.718281 (TeX Live 2012)


(/usr/local/texlive/2012/texmf-dist/fonts/source/public/schulschriften/welasl14
.mf
(/usr/local/texlive/2012/texmf-dist/fonts/source/public/schulschriften/wela14.m
f
(/usr/local/texlive/2012/texmf-dist/fonts/source/public/schulschriften/wela14_d
ef.mf)
(/usr/local/texlive/2012/texmf-dist/fonts/source/public/schulschriften/wela14_g
r.mf [65] [66] [67] [68] [69] [70] [71] [72] [73] [74] [75] [76] [77] [78]
[79] [80] [81] [82] [83] [84] [85] [86] [87] [88] [89] [90] [196] [214]
[220])
(/usr/local/texlive/2012/texmf-dist/fonts/source/public/schulschriften/wela14_k
l.mf [97] [98] [99] [100] [101] [8] [9] [10] [102] [103] [104] [105] [106]
[107] [108] [109] [110] [111] [112] [113] [114] [115] [116] [117] [118]
[119] [120] [121] [122] [255] [228] [246] [252])
(/usr/local/texlive/2012/texmf-dist/fonts/source/public/schulschriften/wela14_s
z.mf [128] [5] [24] [7] [6] [0] [1] [2] [3] [4] [29] [30] [17] [25] [26]
[27] [28] [23] [31] [48] [49] [50] [51] [52] [53] [54] [55] [56] [57] [33]
[34] [35] [36] [37] [38] [159] [39] [40] [41] [42] [43] [44] [45] [46] [47]
[58] [59] [62] [61] [60] [63] [16] [18] [21] [22] [19] [20] [14] [15] [91]
[93] [64] [160])
(/usr/local/texlive/2012/texmf-dist/fonts/source/public/schulschriften/wela14_e
nd.mf
(/usr/local/texlive/2012/texmf-dist/fonts/source/public/schulschriften/wela14_g
r.mf [129] [130] [131] [132] [133] [134] [135] [136] [137] [138] [139] [140]
[141] [142] [143] [144] [145] [146] [147] [148] [149] [150] [151] [152]
[153] [154] [155] [156] [157])
(/usr/local/texlive/2012/texmf-dist/fonts/source/public/schulschriften/wela14_k
l.mf [161] [162] [163] [164] [165] [166] [167] [168] [169] [170] [171] [172]
[173] [174] [175] [176] [177] [178] [179] [180] [181] [182] [183] [184]
[185] [186] [223] [187] [188] [189]))
(/usr/local/texlive/2012/texmf-dist/fonts/source/public/schulschriften/wela14_l
ig.mf) ) )
Font metrics written on welasl14.tfm.
Output written on welasl14.429gf (184 characters, 37012 bytes).
Transcript written on welasl14.log.
mktexpk: 
/home/voss/.texlive2012/texmf-var/fonts/pk/ljfour/public/schulschriften/welasl14.429pk: 
successfully generated.
) )
  276 words of node memory still in use:
    2 hlist, 1 vlist, 1 rule, 2 glue, 2 glyph, 40 glue_spec, 1 write nodes
    avail lists: 2:12,3:6,4:22,5:1,6:33,7:1,9:6,10:1
 
</home/voss/.texlive2012/texmf-var/fonts/pk/ljfour/public/schulschriften/welas
l14.429pk></usr/local/texlive/2012/texmf-dist/fonts/type1/public/amsfonts/cm/cm
r10.pfb>
Output written on Namenlos-4.pdf (1 page, 9470 bytes).
Transcript written on Namenlos-4.log.

From martin at oneiros.de  Sun Nov  4 20:49:35 2012
From: martin at oneiros.de (=?ISO-8859-1?Q?Martin_Schr=F6der?=)
Date: Sun, 4 Nov 2012 20:49:35 +0100
Subject: [luatex] problem with a pk font and ngerman
In-Reply-To: <5096C0FD.5050401@FU-Berlin.DE>
References: <5096C0FD.5050401@FU-Berlin.DE>
Message-ID: <CAP7DCDcvnwApAOAk9tn9E-tA80HcL4=JX4GB141ysDOS7coxEA@mail.gmail.com>

2012/11/4 Herbert Voss <Herbert.Voss at fu-berlin.de>:
> The following example works with pdflatex but not with
> lualatex. Here the letter "a" of "Late" is missing.
> You need an up-to-date TL2012. Without babel or another language
> as ngerman it is also ok. For the test run I deleted everything
> in ~/.texlive2012/texmf-var/

Confirmed; http://tracker.luatex.org/view.php?id=780

Best
   Martin

From luatex at nililand.de  Mon Nov  5 14:39:15 2012
From: luatex at nililand.de (Ulrike Fischer)
Date: Mon, 5 Nov 2012 14:39:15 +0100
Subject: [luatex] problem with a pk font and ngerman
References: <5096C0FD.5050401@FU-Berlin.DE>
Message-ID: <u2xf8u0vs0db$.dlg@nililand.de>

Am Sun, 4 Nov 2012 20:24:45 +0100 schrieb Herbert Voss:

> The following example works with pdflatex but not with
> lualatex. Here the letter "a" of "Late" is missing.
> You need an up-to-date TL2012. Without babel or another language
> as ngerman it is also ok. For the test run I deleted everything
> in ~/.texlive2012/texmf-var/

> I have no idea why ngerman should be a problem with the
> letter a. 

Because of the hyphenmins settings, righthyphenmin is 2 in ngerman
so there is a breakpoint after the a. More interesting is why only
the a is affected:

\documentclass{article}
\usepackage[ngerman]{babel}
\begin{document}
\usefont{T1}{wela}{m}{sl}
Late Lute Lite Lete Kate Mate Xate

\righthyphenmin=3
Late 

Latex 
\end{document}



-- 
Ulrike Fischer 
http://www.troubleshooting-tex.de/


From kmaeda at users.sourceforge.jp  Mon Nov  5 20:01:27 2012
From: kmaeda at users.sourceforge.jp (Kazuki Maeda)
Date: Tue, 6 Nov 2012 04:01:27 +0900
Subject: [luatex] Adobe-Identity-0 fonts in LuaTeX
In-Reply-To: <508E5211.6040204@elvenkind.com>
References: <508C7D0D.5050503@yahoo.co.jp>
 <20121028211504.a68e5274f2272adb9cd6cba5@users.sourceforge.jp>
 <508E5211.6040204@elvenkind.com>
Message-ID: <20121106040127.25f1aebd79093b058ab7bd97@users.sourceforge.jp>

Hello.

On Mon, 29 Oct 2012 10:53:21 +0100
Taco Hoekwater <taco at elvenkind.com> wrote:

> There is a bug in the luatex file search routine that is the cause of
> this: it fails to find Adobe-Identity-0.cidmap (because it is not using
> kpathsea for discovery of that file). As it stands, luatex will only
> find .cidmap files in the current directory. This is definitely a bug.

Thanks. I confirmed what you said. If luatex fails to find the cidmap file,
the cache file kentengeneric.tma has entries as follows:

 ["descriptions"]={
  [0]={
   ["boundingbox"]={ 100, -120, 900, 880 },
   ["cidindex"]=1,
   ["index"]=0,
   ["name"]=".notdef",
   ["width"]=1000,
  },
  {
   ["boundingbox"]=1,
   ["cidindex"]=1,
   ["index"]=1,
   ["name"]="Identity.1",
   ["slookups"]={
    ["ss_l_0_s"]=12,
    ["ss_l_1_s"]=12,
   },
   ["width"]=1000,
  },
...

I removed kentengeneric.tma, copied the cidmap file to the current directory, 
and rerun context. Then I got:

 ["descriptions"]={
  [0]={
   ["boundingbox"]={ 100, -120, 900, 880 },
   ["cidindex"]=1,
   ["index"]=0,
   ["name"]=".notdef",
   ["width"]=1000,
  },
  {
   ["boundingbox"]=1,
   ["cidindex"]=1,
   ["index"]=1,
   ["name"]="uni0001",
   ["slookups"]={
    ["ss_l_0_s"]=12,
    ["ss_l_1_s"]=12,
   },
   ["width"]=1000,
  },
...

The "name" of each glyph changed from "Identity.x" to "uni000x". 
I see, but this does not resolve the problem.


> > By the way, test-xetex.pdf looks fine, but I found a problem.
> > I tried to copy the text in the PDF, then I got:
> > "<U+0002><U+0003><U+0004><U+0005><U+0006><U+0007><U+0008>  <U+000B>".
>
> Adobe Identity maps Kenten Generic exactly like that, and if luatex
> would be able to find the cidmap, you would get the same result.
>
> There is something odd going on with the font's cmap table in that
> it seems to have an internal table that maps the values to the
> \char"2022 etc. but then it says 'Adobe-Identity-0' which seems
> to overrule those, both in ICU and in luatex.

I think that luatex should ignore the cidmap file and use the internal cmap table
when the font is an Adobe-Identity-0 CID-keyed font. This is an exception.
Could luatex's fontloader interpret the internal table?

The latest fontforge (20120731) *without* Adobe-Identity-0.cidmap can recognize
Unicode code point of glyphs in KentenGeneric.otf, e.g.:
(0x0002) U+2022 Identity.2 BULLET

The previous version of fontforge (20110222) can't recognize it:
(0x0002) U+???? Identity.2

Therefore, the latest fontforge might help to resolve this problem.


Best regards,
Kazuki Maeda

From taco at elvenkind.com  Tue Nov  6 08:53:02 2012
From: taco at elvenkind.com (Taco Hoekwater)
Date: Tue, 6 Nov 2012 08:53:02 +0100
Subject: [luatex] Adobe-Identity-0 fonts in LuaTeX
In-Reply-To: <20121106040127.25f1aebd79093b058ab7bd97@users.sourceforge.jp>
References: <508C7D0D.5050503@yahoo.co.jp>
 <20121028211504.a68e5274f2272adb9cd6cba5@users.sourceforge.jp>
 <508E5211.6040204@elvenkind.com>
 <20121106040127.25f1aebd79093b058ab7bd97@users.sourceforge.jp>
Message-ID: <5098C1DE.7080500@elvenkind.com>

On 11/05/2012 08:01 PM, Kazuki Maeda wrote:
>
> The latest fontforge (20120731) *without* Adobe-Identity-0.cidmap can recognize
> Unicode code point of glyphs in KentenGeneric.otf, e.g.:
> (0x0002) U+2022 Identity.2 BULLET
>
> The previous version of fontforge (20110222) can't recognize it:
> (0x0002) U+???? Identity.2
>
> Therefore, the latest fontforge might help to resolve this problem.

Thanks for that information. I must warn you that this may take a
quite while, though. We are already having a hard time integrating the
TeXLive changes from the previous year, and the luatex source is much
closer to that tree than that 'luafontloader' is to current fontforge.

Best wishes,
Taco


From mailing_list at arcor.de  Tue Nov  6 18:09:24 2012
From: mailing_list at arcor.de (Stephan Hennig)
Date: Tue, 6 Nov 2012 18:09:24 +0100
Subject: [luatex] managing user_defined whatsit nodes
Message-ID: <50994444.2010807@arcor.de>

Hi,

user-defined whatsit nodes (see sec. 8.1.4.25 in luatexref-t.pdf) are an
alternative to attributes for storing information in a node list.  But
how does a user (package writer) tell between his user-defined whatsit
nodes and third party user-defined whatsit nodes?  Is there a way to
allocate at run-time a unique identifier to mark nodes, similar to the
attribute allocation mechanism provided by package luatexbase?

Best regards,
Stephan Hennig

From patrick at gundla.ch  Tue Nov  6 20:03:03 2012
From: patrick at gundla.ch (Patrick Gundlach)
Date: Tue, 6 Nov 2012 20:03:03 +0100
Subject: [luatex] managing user_defined whatsit nodes
In-Reply-To: <50994444.2010807@arcor.de>
References: <50994444.2010807@arcor.de>
Message-ID: <44631CE7-FAE7-466C-B5FA-9C8E86F02E84@gundla.ch>



>  Is there a way to
> allocate at run-time a unique identifier to mark nodes, similar to the
> attribute allocation mechanism provided by package luatexbase?

not that I know of. It would be a good extension to the luatexbase package.

Patrick


From mailing_list at arcor.de  Wed Nov  7 19:37:19 2012
From: mailing_list at arcor.de (Stephan Hennig)
Date: Wed, 7 Nov 2012 19:37:19 +0100
Subject: [luatex] Behavior of node lists.
In-Reply-To: <4E14667E.7010201@elvenkind.com>
References: <4E11668A.8050208@free.fr> <4E14667E.7010201@elvenkind.com>
Message-ID: <509AAA5F.7090304@arcor.de>

Am 06.07.2011 15:43, schrieb Taco Hoekwater:
> On 07/04/11 09:06, Paul Isambert wrote:
>> 
>> The manual says you're in charge of ensuring that in
>> "node.insert_after(H, N, x)", N is in the list denoted by H. The thing
>> is, H doesn't seem to matter at all, unless it's nil:
> 
> Actually H is also useful if N is nil (that is a tail-append the list
> that starts at H), but it is true that H is generally unused.

If N is known to be non-nil, e.g., a glyph node, is it save to call

  node.insert_after(nil, N, x)  ?


If the answer is 'Yes', I propose re-ordering parameters of function
node.insert_after (and node.insert_before), so that head can be easily
left out in the function call:

  function node.insert_after(<new>, <current>, <head>)

Best regards,
Stephan Hennig


From stephanhennig at arcor.de  Wed Nov  7 20:11:55 2012
From: stephanhennig at arcor.de (Stephan Hennig)
Date: Wed, 7 Nov 2012 20:11:55 +0100
Subject: [luatex] managing user_defined whatsit nodes
In-Reply-To: <44631CE7-FAE7-466C-B5FA-9C8E86F02E84@gundla.ch>
References: <50994444.2010807@arcor.de>
 <44631CE7-FAE7-466C-B5FA-9C8E86F02E84@gundla.ch>
Message-ID: <509AB27B.10302@arcor.de>

Am 06.11.2012 20:03, schrieb Patrick Gundlach:

>> Is there a way to allocate at run-time a unique identifier to mark
>> nodes, similar to the attribute allocation mechanism provided by
>> package luatexbase?
> 
> not that I know of. It would be a good extension to the luatexbase package.

I've opened an issue, <URL:https://github.com/mpg/luatexbase/issues/8>

Best regards,
Stephan Hennig


From taco at elvenkind.com  Thu Nov  8 09:15:01 2012
From: taco at elvenkind.com (Taco Hoekwater)
Date: Thu, 8 Nov 2012 09:15:01 +0100
Subject: [luatex] Behavior of node lists.
In-Reply-To: <509AAA5F.7090304@arcor.de>
References: <4E11668A.8050208@free.fr> <4E14667E.7010201@elvenkind.com>
 <509AAA5F.7090304@arcor.de>
Message-ID: <509B6A05.2050708@elvenkind.com>

On 11/07/2012 07:37 PM, Stephan Hennig wrote:
> Am 06.07.2011 15:43, schrieb Taco Hoekwater:
>> On 07/04/11 09:06, Paul Isambert wrote:
>>>
>>> The manual says you're in charge of ensuring that in
>>> "node.insert_after(H, N, x)", N is in the list denoted by H. The thing
>>> is, H doesn't seem to matter at all, unless it's nil:
>>
>> Actually H is also useful if N is nil (that is a tail-append the list
>> that starts at H), but it is true that H is generally unused.
>
> If N is known to be non-nil, e.g., a glyph node, is it save to call
>
>    node.insert_after(nil, N, x)  ?
>
> If the answer is 'Yes',

Well, yes. However I do not like the idea of reordering the
arguments, because we have quite a lot of functions with 'head'
argument, and they always come first.

Best wishes,
Taco

> I propose re-ordering parameters of function
> node.insert_after (and node.insert_before), so that head can be easily
> left out in the function call:
>
>    function node.insert_after(<new>, <current>, <head>)
>
> Best regards,
> Stephan Hennig
>


From zappathustra at free.fr  Thu Nov  8 09:38:07 2012
From: zappathustra at free.fr (Paul Isambert)
Date: Thu, 8 Nov 2012 09:38:07 +0100
Subject: [luatex] Behavior of node lists.
In-Reply-To: <509B6A05.2050708@elvenkind.com>
References: <4E11668A.8050208@free.fr> <4E14667E.7010201@elvenkind.com>
 <509AAA5F.7090304@arcor.de> <509B6A05.2050708@elvenkind.com>
Message-ID: <1352363887.509b6f6f05609@imp.free.fr>

Selon Taco Hoekwater <taco at elvenkind.com>:

> On 11/07/2012 07:37 PM, Stephan Hennig wrote:
> > Am 06.07.2011 15:43, schrieb Taco Hoekwater:
> >> On 07/04/11 09:06, Paul Isambert wrote:
> >>>
> >>> The manual says you're in charge of ensuring that in
> >>> "node.insert_after(H, N, x)", N is in the list denoted by H. The thing
> >>> is, H doesn't seem to matter at all, unless it's nil:
> >>
> >> Actually H is also useful if N is nil (that is a tail-append the list
> >> that starts at H), but it is true that H is generally unused.
> >
> > If N is known to be non-nil, e.g., a glyph node, is it save to call
> >
> >    node.insert_after(nil, N, x)  ?
> >
> > If the answer is 'Yes',
>
> Well, yes. However I do not like the idea of reordering the
> arguments, because we have quite a lot of functions with 'head'
> argument, and they always come first.

I definitely agree (don't want to rewrite umpteen files). Plus the optionality
of the head makes less sense than the optionality of the current node, even if
it were more frequent; it'd mean you have to check beforehand whether the
current node exists or not before you use the function. If the head is a
mandatory argument, you just don't ask question. (Anyway when an argument can be
nil, you always pass it to the function, no matter whether it's labelled
optional or not.)

Best,
Paul



From pragma at wxs.nl  Thu Nov  8 11:40:54 2012
From: pragma at wxs.nl (Hans Hagen)
Date: Thu, 8 Nov 2012 11:40:54 +0100
Subject: [luatex] Behavior of node lists.
In-Reply-To: <509B6A05.2050708@elvenkind.com>
References: <4E11668A.8050208@free.fr> <4E14667E.7010201@elvenkind.com>
 <509AAA5F.7090304@arcor.de> <509B6A05.2050708@elvenkind.com>
Message-ID: <509B8C36.6090506@wxs.nl>

On 11/8/2012 9:15 AM, Taco Hoekwater wrote:
> On 11/07/2012 07:37 PM, Stephan Hennig wrote:
>> Am 06.07.2011 15:43, schrieb Taco Hoekwater:
>>> On 07/04/11 09:06, Paul Isambert wrote:
>>>>
>>>> The manual says you're in charge of ensuring that in
>>>> "node.insert_after(H, N, x)", N is in the list denoted by H. The thing
>>>> is, H doesn't seem to matter at all, unless it's nil:
>>>
>>> Actually H is also useful if N is nil (that is a tail-append the list
>>> that starts at H), but it is true that H is generally unused.
>>
>> If N is known to be non-nil, e.g., a glyph node, is it save to call
>>
>>    node.insert_after(nil, N, x)  ?
>>
>> If the answer is 'Yes',
>
> Well, yes. However I do not like the idea of reordering the
> arguments, because we have quite a lot of functions with 'head'
> argument, and they always come first.

indeed reordering in no option

(we could consider a two argument variant i.e. if two arguments, then 
assume N, x)

> Best wishes,
> Taco
>
>> I propose re-ordering parameters of function
>> node.insert_after (and node.insert_before), so that head can be easily
>> left out in the function call:
>>
>>    function node.insert_after(<new>, <current>, <head>)
>>
>> Best regards,
>> Stephan Hennig
>>
>


-- 

-----------------------------------------------------------------
                                           Hans Hagen | PRAGMA ADE
               Ridderstraat 27 | 8061 GH Hasselt | The Netherlands
     tel: 038 477 53 69 | voip: 087 875 68 74 | www.pragma-ade.com
                                              | www.pragma-pod.nl
-----------------------------------------------------------------

From stephanhennig at arcor.de  Thu Nov  8 22:34:54 2012
From: stephanhennig at arcor.de (Stephan Hennig)
Date: Thu, 8 Nov 2012 22:34:54 +0100
Subject: [luatex] Behavior of node lists.
In-Reply-To: <1352363887.509b6f6f05609@imp.free.fr>
References: <4E11668A.8050208@free.fr> <4E14667E.7010201@elvenkind.com>
 <509AAA5F.7090304@arcor.de> <509B6A05.2050708@elvenkind.com>
 <1352363887.509b6f6f05609@imp.free.fr>
Message-ID: <509C257E.4030204@arcor.de>

Am 08.11.2012 09:38, schrieb Paul Isambert:
> Selon Taco Hoekwater <taco at elvenkind.com>:
> 
>> On 11/07/2012 07:37 PM, Stephan Hennig wrote:
>> > Am 06.07.2011 15:43, schrieb Taco Hoekwater:
>> >> On 07/04/11 09:06, Paul Isambert wrote:
>> >>>
>> >>> The manual says you're in charge of ensuring that in
>> >>> "node.insert_after(H, N, x)", N is in the list denoted by H. The thing
>> >>> is, H doesn't seem to matter at all, unless it's nil:
>> >>
>> >> Actually H is also useful if N is nil (that is a tail-append the list
>> >> that starts at H), but it is true that H is generally unused.
>> >
>> > If N is known to be non-nil, e.g., a glyph node, is it save to call
>> >
>> >    node.insert_after(nil, N, x)  ?
>> >
>> > If the answer is 'Yes',
>>
>> Well, yes. However I do not like the idea of reordering the
>> arguments, because we have quite a lot of functions with 'head'
>> argument, and they always come first.
> 
> I definitely agree (don't want to rewrite umpteen files).

Come-on!  There might be umpteen TeX and LaTeX files, but no Lua code
files that use node.insert_after.


> Plus the optionality of the head makes less sense than the
> optionality of the current node, even if it were more frequent; it'd
> mean you have to check beforehand whether the current node exists or
> not before you use the function.

Well, in my use-case, current is always a valid node.  So I wondered why
head were needed at all.  But your use-cases might differ.  But then
again, current has to be checked for being nil anyway (even if that is
hidden in the function).


> If the head is a mandatory argument, you just don't ask question.

I think inserting a node at the end of a given head node is something
different than inserting a node exactly after a given node.  I you want
to do the former, you could always say

  insert_after(node.tail(head), new)

Best regards,
Stephan Hennig


From pragma at wxs.nl  Thu Nov  8 23:09:52 2012
From: pragma at wxs.nl (Hans Hagen)
Date: Thu, 8 Nov 2012 23:09:52 +0100
Subject: [luatex] Behavior of node lists.
In-Reply-To: <509C2266.2030609@arcor.de>
References: <4E11668A.8050208@free.fr> <4E14667E.7010201@elvenkind.com>
 <509AAA5F.7090304@arcor.de> <509B6A05.2050708@elvenkind.com>
 <509B8C36.6090506@wxs.nl> <509C2266.2030609@arcor.de>
Message-ID: <509C2DB0.3080902@wxs.nl>

On 11/8/2012 10:21 PM, Stephan Hennig wrote:

> That is, the first argument <head> is actually never needed.  Though, on

maybe in your code, but in mine it's needed in most cases

> the former line, you can't easily tell what happens, just from the
> arguments.  You need to know about the current == nil case.  And I
> guess, insert_after calls node.tail(head) behind the scenes anyway when
> current == nil.  The current function insert_after is making things more
> complicated than necessary, I think.  Am I missing something?

that there are all kind of usage

>
>> indeed reordering in no option
>>
>> (we could consider a two argument variant i.e. if two arguments, then
>> assume N, x)
>
> At the cost of an additional argument check.  Undesirable as well ...

depends ... just a nil check in c ... but anyhow, you write a wrapper:

you can consider wrapping it in a helper:

function i_a(n,current,head)
     return node.insert_after(head,current,n)
end

the overhead is neglectable

Hans



-----------------------------------------------------------------
                                           Hans Hagen | PRAGMA ADE
               Ridderstraat 27 | 8061 GH Hasselt | The Netherlands
     tel: 038 477 53 69 | voip: 087 875 68 74 | www.pragma-ade.com
                                              | www.pragma-pod.nl
-----------------------------------------------------------------

From pragma at wxs.nl  Thu Nov  8 23:34:49 2012
From: pragma at wxs.nl (Hans Hagen)
Date: Thu, 8 Nov 2012 23:34:49 +0100
Subject: [luatex] Behavior of node lists.
In-Reply-To: <509C257E.4030204@arcor.de>
References: <4E11668A.8050208@free.fr> <4E14667E.7010201@elvenkind.com>
 <509AAA5F.7090304@arcor.de> <509B6A05.2050708@elvenkind.com>
 <1352363887.509b6f6f05609@imp.free.fr> <509C257E.4030204@arcor.de>
Message-ID: <509C3389.4090207@wxs.nl>

On 11/8/2012 10:34 PM, Stephan Hennig wrote:

> Come-on!  There might be umpteen TeX and LaTeX files, but no Lua code
> files that use node.insert_after.

Are you joking? 40 files on my machine, and over 250 calls to 
insert_before and insert_after, but I must admit that they're not latex 
files and probably do a-typical things.

> I think inserting a node at the end of a given head node is something
> different than inserting a node exactly after a given node.  I you want
> to do the former, you could always say
>
>    insert_after(node.tail(head), new)

that inserts a node at the end of a list starting with head which is not 
always the same as inserting after head

quite some callbacks expect a head to be returned and get a head passed, so

head = node.insert_after(head,somenode,newnode)

is pretty standard and catches the cases where head == somenode which 
saves some testing. Of course you can always do it the manual way: by 
assigning next/prev fields.

Hans

(ps. Sorry for being persistent, normally I don't follow this list as I 
filter all messages but have to reinstall the filter)

-----------------------------------------------------------------
                                           Hans Hagen | PRAGMA ADE
               Ridderstraat 27 | 8061 GH Hasselt | The Netherlands
     tel: 038 477 53 69 | voip: 087 875 68 74 | www.pragma-ade.com
                                              | www.pragma-pod.nl
-----------------------------------------------------------------

From mailing_list at arcor.de  Thu Nov  8 22:47:33 2012
From: mailing_list at arcor.de (Stephan Hennig)
Date: Thu, 8 Nov 2012 22:47:33 +0100
Subject: [luatex] robustness of node.traverse
Message-ID: <509C2875.4030905@arcor.de>

Hi,

the manual is quite terse about node.traverse().  I'd like to know what
operations (insertion/removal) on the node list given as argument to
node.traverse() are save in a loop like

  for n in node.traverse(head) do
    ...
  end

I'd guess removing the current node in the loop body is not a good idea.
 But anything else?  Sure, inserting before/after the current node
changes the current node, too.  But that shouldn't be a problem, should it?

Best regards,
Stephan Hennig

From mailing_list at arcor.de  Thu Nov  8 22:21:42 2012
From: mailing_list at arcor.de (Stephan Hennig)
Date: Thu, 8 Nov 2012 22:21:42 +0100
Subject: [luatex] Behavior of node lists.
In-Reply-To: <509B8C36.6090506@wxs.nl>
References: <4E11668A.8050208@free.fr> <4E14667E.7010201@elvenkind.com>
 <509AAA5F.7090304@arcor.de> <509B6A05.2050708@elvenkind.com>
 <509B8C36.6090506@wxs.nl>
Message-ID: <509C2266.2030609@arcor.de>

Am 08.11.2012 11:40, schrieb Hans Hagen:
> On 11/8/2012 9:15 AM, Taco Hoekwater wrote:
>> On 11/07/2012 07:37 PM, Stephan Hennig wrote:
>>>
>>> If N is known to be non-nil, e.g., a glyph node, is it save to call
>>>
>>>    node.insert_after(nil, N, x)  ?
>>>
>>> If the answer is 'Yes',
>>
>> Well, yes.

Thanks!  Could that be clarified in the manual, please?  Made me wonder
why head were needed to insert a node after another node the first time
I read it.


>> However I do not like the idea of reordering the arguments,

No problem.  But let me respond to your arguments anyway.


>> because we have quite a lot of functions with 'head' argument, and 
>> they always come first.

I don't think this is a fair argument.  In node.insert_after, parameter
head plays only a secondary role.  It is only used if current -- the
primary parameter -- is nil.  And even then,

  insert_after(head, nil, new)

is just an opaque way of saying

  insert_after(nil, node.tail(head), new)

That is, the first argument <head> is actually never needed.  Though, on
the former line, you can't easily tell what happens, just from the
arguments.  You need to know about the current == nil case.  And I
guess, insert_after calls node.tail(head) behind the scenes anyway when
current == nil.  The current function insert_after is making things more
complicated than necessary, I think.  Am I missing something?


> indeed reordering in no option
> 
> (we could consider a two argument variant i.e. if two arguments, then 
> assume N, x)

At the cost of an additional argument check.  Undesirable as well ...

Best regards,
Stephan Hennig


From pragma at wxs.nl  Fri Nov  9 00:44:08 2012
From: pragma at wxs.nl (Hans Hagen)
Date: Fri, 9 Nov 2012 00:44:08 +0100
Subject: [luatex] robustness of node.traverse
In-Reply-To: <509C2875.4030905@arcor.de>
References: <509C2875.4030905@arcor.de>
Message-ID: <509C43C8.3020901@wxs.nl>

On 11/8/2012 10:47 PM, Stephan Hennig wrote:
> Hi,
>
> the manual is quite terse about node.traverse().  I'd like to know what
> operations (insertion/removal) on the node list given as argument to
> node.traverse() are save in a loop like
>
>    for n in node.traverse(head) do
>      ...
>    end

best is not to remove n and mess with the n.next pointer

the traverse is mostly there for fast loops that only deal with the 
properties of nodes

> I'd guess removing the current node in the loop body is not a good idea.
>   But anything else?  Sure, inserting before/after the current node
> changes the current node, too.  But that shouldn't be a problem, should it?

in that case best use

local n = head
while n do
   ...
   n = n.next
end

(often just as efficient)

Hans

-----------------------------------------------------------------
                                           Hans Hagen | PRAGMA ADE
               Ridderstraat 27 | 8061 GH Hasselt | The Netherlands
     tel: 038 477 53 69 | voip: 087 875 68 74 | www.pragma-ade.com
                                              | www.pragma-pod.nl
-----------------------------------------------------------------

From patrick at gundla.ch  Fri Nov  9 09:39:57 2012
From: patrick at gundla.ch (Patrick Gundlach)
Date: Fri, 9 Nov 2012 09:39:57 +0100
Subject: [luatex] Behavior of node lists.
In-Reply-To: <509C257E.4030204@arcor.de>
References: <4E11668A.8050208@free.fr> <4E14667E.7010201@elvenkind.com>
 <509AAA5F.7090304@arcor.de> <509B6A05.2050708@elvenkind.com>
 <1352363887.509b6f6f05609@imp.free.fr> <509C257E.4030204@arcor.de>
Message-ID: <69CDA1DA-0BC1-4DD7-9CAD-72DDE97DC0FA@gundla.ch>

(node.insert_after)

>> I definitely agree (don't want to rewrite umpteen files).
> 
> Come-on!  There might be umpteen TeX and LaTeX files, but no Lua code
> files that use node.insert_after.


well, I know that LuaTeX is beta and thus everything can change, but if I had a vote, I'd strongly vote against changing such a fundamental function. I _am_ using it in umpteen places.

But I know that nobody's seriously considering a change.

Patrick




From taco at elvenkind.com  Fri Nov  9 09:58:03 2012
From: taco at elvenkind.com (Taco Hoekwater)
Date: Fri, 9 Nov 2012 09:58:03 +0100
Subject: [luatex] robustness of node.traverse
In-Reply-To: <509C2875.4030905@arcor.de>
References: <509C2875.4030905@arcor.de>
Message-ID: <509CC59B.4080008@elvenkind.com>

On 11/08/2012 10:47 PM, Stephan Hennig wrote:
> Hi,
>
> the manual is quite terse about node.traverse().

Please check the latest manual commit, I added an explanation
of the internals of node.traverse() and node.traverse_id() that
should make things clearer.

Best wishes,
Taco


From khaledhosny at eglug.org  Fri Nov  9 10:10:30 2012
From: khaledhosny at eglug.org (Khaled Hosny)
Date: Fri, 9 Nov 2012 11:10:30 +0200
Subject: [luatex] Behavior of node lists.
In-Reply-To: <509C257E.4030204@arcor.de>
References: <4E11668A.8050208@free.fr> <4E14667E.7010201@elvenkind.com>
 <509AAA5F.7090304@arcor.de> <509B6A05.2050708@elvenkind.com>
 <1352363887.509b6f6f05609@imp.free.fr> <509C257E.4030204@arcor.de>
Message-ID: <20121109091030.GA23058@khaled-laptop>

On Thu, Nov 08, 2012 at 10:34:54PM +0100, Stephan Hennig wrote:
> Come-on!  There might be umpteen TeX and LaTeX files, but no Lua code
> files that use node.insert_after.

I can?t even count how many times I used it!.


From patrick at gundla.ch  Fri Nov  9 10:14:40 2012
From: patrick at gundla.ch (Patrick Gundlach)
Date: Fri, 9 Nov 2012 10:14:40 +0100
Subject: [luatex] Behavior of node lists.
In-Reply-To: <20121109091030.GA23058@khaled-laptop>
References: <4E11668A.8050208@free.fr> <4E14667E.7010201@elvenkind.com>
 <509AAA5F.7090304@arcor.de> <509B6A05.2050708@elvenkind.com>
 <1352363887.509b6f6f05609@imp.free.fr> <509C257E.4030204@arcor.de>
 <20121109091030.GA23058@khaled-laptop>
Message-ID: <8B1395C6-87A4-4C89-96F9-FD82829FD7F3@gundla.ch>


Am 09.11.2012 um 10:10 schrieb Khaled Hosny <khaledhosny at eglug.org>:

> On Thu, Nov 08, 2012 at 10:34:54PM +0100, Stephan Hennig wrote:
>> Come-on!  There might be umpteen TeX and LaTeX files, but no Lua code
>> files that use node.insert_after.
> 
> I can?t even count how many times I used it!.

grep -r node.insert_after *  | wc -l

;)

Patrick

(just kidding, of course)



From khaledhosny at eglug.org  Fri Nov  9 10:27:46 2012
From: khaledhosny at eglug.org (Khaled Hosny)
Date: Fri, 9 Nov 2012 11:27:46 +0200
Subject: [luatex] Behavior of node lists.
In-Reply-To: <8B1395C6-87A4-4C89-96F9-FD82829FD7F3@gundla.ch>
References: <4E11668A.8050208@free.fr> <4E14667E.7010201@elvenkind.com>
 <509AAA5F.7090304@arcor.de> <509B6A05.2050708@elvenkind.com>
 <1352363887.509b6f6f05609@imp.free.fr> <509C257E.4030204@arcor.de>
 <20121109091030.GA23058@khaled-laptop>
 <8B1395C6-87A4-4C89-96F9-FD82829FD7F3@gundla.ch>
Message-ID: <20121109092746.GA19750@khaled-laptop>

On Fri, Nov 09, 2012 at 10:14:40AM +0100, Patrick Gundlach wrote:
> 
> Am 09.11.2012 um 10:10 schrieb Khaled Hosny <khaledhosny at eglug.org>:
> 
> > On Thu, Nov 08, 2012 at 10:34:54PM +0100, Stephan Hennig wrote:
> >> Come-on!  There might be umpteen TeX and LaTeX files, but no Lua code
> >> files that use node.insert_after.
> > 
> > I can?t even count how many times I used it!.
> 
> grep -r node.insert_after *  | wc -l

It means I have to remember what lua files I wrote in the first place,
unless you want me to do a find / as well :p

From Robin.Fairbairns at cl.cam.ac.uk  Fri Nov  9 11:46:12 2012
From: Robin.Fairbairns at cl.cam.ac.uk (Robin Fairbairns)
Date: Fri, 9 Nov 2012 10:46:12 +0000
Subject: [luatex] Behavior of node lists.
In-Reply-To: Your message of Fri, 09 Nov 2012 11:10:30 +0200.
 <20121109091030.GA23058@khaled-laptop>
Message-ID: <4858.1352457972@cl.cam.ac.uk>

Khaled Hosny <khaledhosny at eglug.org> wrote:

> On Thu, Nov 08, 2012 at 10:34:54PM +0100, Stephan Hennig wrote:
> > Come-on!  There might be umpteen TeX and LaTeX files, but no Lua code
> > files that use node.insert_after.
> 
> I can?t even count how many times I used it!.

so \aleph_1 ?


From mailing_list at arcor.de  Fri Nov  9 20:48:31 2012
From: mailing_list at arcor.de (Stephan Hennig)
Date: Fri, 9 Nov 2012 20:48:31 +0100
Subject: [luatex] Behavior of node lists.
In-Reply-To: <509C2DB0.3080902@wxs.nl>
References: <4E11668A.8050208@free.fr> <4E14667E.7010201@elvenkind.com>
 <509AAA5F.7090304@arcor.de> <509B6A05.2050708@elvenkind.com>
 <509B8C36.6090506@wxs.nl> <509C2266.2030609@arcor.de>
 <509C2DB0.3080902@wxs.nl>
Message-ID: <509D5E0F.2040405@arcor.de>

Am 08.11.2012 23:09, schrieb Hans Hagen:
> On 11/8/2012 10:21 PM, Stephan Hennig wrote:
> 
>> That is, the first argument <head> is actually never needed.  Though, on
> 
> maybe in your code, but in mine it's needed in most cases

Interesting, could you please give a use-case?  Mine is to insert
whatsit nodes to store additional information in a node list.  And I'm
inserting that only behind valid nodes.  Then I was puzzled seeing head
is needed to insert a node, which is (now was) not available at that point.


> you can consider wrapping it in a helper:
> 
> function i_a(n,current,head)
>      return node.insert_after(head,current,n)
> end

No, I've changed my code so that head is available now.

Two follow-up questions:  Only after my initial post I have seen that
insert_before and insert_after return head and new.  To quote the manual:

| The return values are the (potentially mutated) head and the node
| new, set up to be part of the list (with correct next field).

Does that mean, after calling insert_after, head and new can be
different nodes that that given as argument to the function?  If only
fields in the original nodes are updated, what's the purpose of
returning the nodes again?

Second, when inserting nodes into a deeply nested node list, is the head
argument to insert_after the head of the current branch (latest hlist or
vlist head) or the top-level head of the node list?

Best regards,
Stephan Hennig


From pragma at wxs.nl  Fri Nov  9 21:44:48 2012
From: pragma at wxs.nl (Hans Hagen)
Date: Fri, 9 Nov 2012 21:44:48 +0100
Subject: [luatex] Behavior of node lists.
In-Reply-To: <509D5E0F.2040405@arcor.de>
References: <4E11668A.8050208@free.fr> <4E14667E.7010201@elvenkind.com>
 <509AAA5F.7090304@arcor.de> <509B6A05.2050708@elvenkind.com>
 <509B8C36.6090506@wxs.nl> <509C2266.2030609@arcor.de>
 <509C2DB0.3080902@wxs.nl> <509D5E0F.2040405@arcor.de>
Message-ID: <509D6B40.6050705@wxs.nl>

On 11/9/2012 8:48 PM, Stephan Hennig wrote:
> Am 08.11.2012 23:09, schrieb Hans Hagen:
>> On 11/8/2012 10:21 PM, Stephan Hennig wrote:
>>
>>> That is, the first argument <head> is actually never needed.  Though, on
>>
>> maybe in your code, but in mine it's needed in most cases
>
> Interesting, could you please give a use-case?  Mine is to insert
> whatsit nodes to store additional information in a node list.  And I'm
> inserting that only behind valid nodes.  Then I was puzzled seeing head
> is needed to insert a node, which is (now was) not available at that point.

if you insert in a node list that represents a paragraph then you're 
normally doing things after the head node (being a par whatsit) but if 
you want to insert your whatsit in front of a head of an hbox list then 
you insert before head and need to set the new head of that box to point 
to your whatsit.

concerning 'valid' ... in principle each node had better be a valid one

> | The return values are the (potentially mutated) head and the node
> | new, set up to be part of the list (with correct next field).
>
> Does that mean, after calling insert_after, head and new can be
> different nodes that that given as argument to the function?  If only
> fields in the original nodes are updated, what's the purpose of
> returning the nodes again?

after and before have a consistent similar interface so you can make 
'generic' functions that get insert_before or insert_after passed, so 
it's mostly about consistency in interfaces

the advantage of passing head to insert_after is that when head is nil 
at the start of whatever you do, you get a head back:

-- head can have a value or can be nil, maybe because the head
-- node was deletes as part of an earlier action

head, n = node.insert_after(head,n,somenewnode)

it saves you an

if not head then
   head = n
end

test

> Second, when inserting nodes into a deeply nested node list, is the head
> argument to insert_after the head of the current branch (latest hlist or
> vlist head) or the top-level head of the node list?

always the head of the 'current' list

Hans

-----------------------------------------------------------------
                                           Hans Hagen | PRAGMA ADE
               Ridderstraat 27 | 8061 GH Hasselt | The Netherlands
     tel: 038 477 53 69 | voip: 087 875 68 74 | www.pragma-ade.com
                                              | www.pragma-pod.nl
-----------------------------------------------------------------

From mailing_list at arcor.de  Fri Nov  9 21:22:19 2012
From: mailing_list at arcor.de (Stephan Hennig)
Date: Fri, 9 Nov 2012 21:22:19 +0100
Subject: [luatex] Behavior of node lists.
In-Reply-To: <509B6A05.2050708@elvenkind.com>
References: <4E11668A.8050208@free.fr> <4E14667E.7010201@elvenkind.com>
 <509AAA5F.7090304@arcor.de> <509B6A05.2050708@elvenkind.com>
Message-ID: <509D65FB.7040406@arcor.de>

Am 08.11.2012 09:15, schrieb Taco Hoekwater:
> On 11/07/2012 07:37 PM, Stephan Hennig wrote:
>> Am 06.07.2011 15:43, schrieb Taco Hoekwater:
>>>
>>> Actually H is also useful if N is nil (that is a tail-append the list
>>> that starts at H), but it is true that H is generally unused.
>>
>> If N is known to be non-nil, e.g., a glyph node, is it save to call
>>
>>    node.insert_after(nil, N, x)  ?
>>
>> If the answer is 'Yes',
> 
> Well, yes.

Hmm, I've just found

| If head is initially nil, it will become new.

That is,

  node.insert_after(nil, N, x)

is not a short-cut for inserting after N, but returns x as new head?

Best regards,
Stephan Hennig


From pragma at wxs.nl  Fri Nov  9 22:10:20 2012
From: pragma at wxs.nl (Hans Hagen)
Date: Fri, 9 Nov 2012 22:10:20 +0100
Subject: [luatex] Behavior of node lists.
In-Reply-To: <509D65FB.7040406@arcor.de>
References: <4E11668A.8050208@free.fr> <4E14667E.7010201@elvenkind.com>
 <509AAA5F.7090304@arcor.de> <509B6A05.2050708@elvenkind.com>
 <509D65FB.7040406@arcor.de>
Message-ID: <509D713C.8070706@wxs.nl>

On 11/9/2012 9:22 PM, Stephan Hennig wrote:

> That is,
>
>    node.insert_after(nil, N, x)
>
> is not a short-cut for inserting after N, but returns x as new head?

no, it returns n as head as well as x:

   head, current = node.insert_after(nil,current,x)

boils down to

   head    = current
   current = x

so:

   head, current = node.insert_after(head,current,x)

becomes:

   head    = head or current or x
   current = x

Hans

-----------------------------------------------------------------
                                           Hans Hagen | PRAGMA ADE
               Ridderstraat 27 | 8061 GH Hasselt | The Netherlands
     tel: 038 477 53 69 | voip: 087 875 68 74 | www.pragma-ade.com
                                              | www.pragma-pod.nl
-----------------------------------------------------------------

From mailing_list at arcor.de  Fri Nov  9 20:19:40 2012
From: mailing_list at arcor.de (Stephan Hennig)
Date: Fri, 9 Nov 2012 20:19:40 +0100
Subject: [luatex] robustness of node.traverse
In-Reply-To: <509CC59B.4080008@elvenkind.com>
References: <509C2875.4030905@arcor.de> <509CC59B.4080008@elvenkind.com>
Message-ID: <509D574C.6040600@arcor.de>

Am 09.11.2012 09:58, schrieb Taco Hoekwater:

> Please check the latest manual commit, I added an explanation
> of the internals of node.traverse() and node.traverse_id() that
> should make things clearer.

Thanks!  To quote

| \starttyping
| for n in node.traverse(head) do
|    ...
| end
| \stoptyping
|
| is functionally equivalent to:
|
| \starttyping
| do
|   local n
|   local function f (head,var)
|     local t
|     if var == nil then
|        t = head
|     else
|        t = var.next
|     end
|     return t
|   end
|   while true do
|     n = f (head, n)
|     if n == nil then break end
|     ...
|   end
| end
| \stoptyping

What is the advantage of this to the naive

  local n = head
  while n do
    ...
    n = n.next
  end

?

Regarding traverse_id

| \starttyping
|   local function f (head,var)
|     local t
|     if var == nil then
|        t = head
|     else
|        t = var.next
|     end
|     while not t.id == id do
|        t = t.next
|     end

There is a guard missing in the while loop that stops when t == nil.

|     return t
|   end
| \stoptyping

Again, what is the advantage of this to the naive

  local n = head
  while n do
    if n.id == <id> then
      ...
    end
    n = n.next
  end

?

Best regards,
Stephan Hennig


From pragma at wxs.nl  Sat Nov 10 00:09:49 2012
From: pragma at wxs.nl (Hans Hagen)
Date: Sat, 10 Nov 2012 00:09:49 +0100
Subject: [luatex] robustness of node.traverse
In-Reply-To: <509D574C.6040600@arcor.de>
References: <509C2875.4030905@arcor.de> <509CC59B.4080008@elvenkind.com>
 <509D574C.6040600@arcor.de>
Message-ID: <509D8D3D.8000506@wxs.nl>

On 11/9/2012 8:19 PM, Stephan Hennig wrote:

> What is the advantage of this to the naive
>
>    local n = head
>    while n do
>      ...
>      n = n.next
>    end

convenience

> Regarding traverse_id

> Again, what is the advantage of this to the naive
>
>    local n = head
>    while n do
>      if n.id == <id> then
>        ...
>      end
>      n = n.next
>    end

speed, as in jumps over (successive) nodes that don't match id and it 
saves at least one function call per lookup.

Anyhow, it all depends on the kind of code you write. In practice node 
lists are relatively small so you can choose the loop method that you 
like most. So, when you manipulate the list, the method that you call 
'naive' is often the most suitable.

Hans

-----------------------------------------------------------------
                                           Hans Hagen | PRAGMA ADE
               Ridderstraat 27 | 8061 GH Hasselt | The Netherlands
     tel: 038 477 53 69 | voip: 087 875 68 74 | www.pragma-ade.com
                                              | www.pragma-pod.nl
-----------------------------------------------------------------

From taco at docwolves.nl  Sat Nov 10 00:14:52 2012
From: taco at docwolves.nl (Taco hoekwater)
Date: Sat, 10 Nov 2012 00:14:52 +0100
Subject: [luatex] robustness of node.traverse
In-Reply-To: <509D574C.6040600@arcor.de>
References: <509C2875.4030905@arcor.de> <509CC59B.4080008@elvenkind.com>
 <509D574C.6040600@arcor.de>
Message-ID: <E7845790-18F4-4A94-A64B-4F9E92AFC0F5@docwolves.nl>

Hi,

Op 9 nov. 2012 om 20:19 heeft Stephan Hennig <mailing_list at arcor.de> het volgende geschreven:

> Am 09.11.2012 09:58, schrieb Taco Hoekwater:

> What is the advantage of this to the naive
> 
>  local n = head
>  while n do
>    ...
>    n = n.next
>  end
> 
> ?

Not a lot, but some people prefer the writing style with for loops. Running speed
is comparable for both styles of looping, if I recall correctly. 

> 
>  a guard missing in the while loop that stops when t == nil.
> 

It is in the code, of course. The explanation was getting long, so I skipped that.

> |     return t
> |   end
> | \stoptyping
> 
> Again, what is the advantage of this to the naive
> 
>  local n = head
>  while n do
>    if n.id == <id> then
>      ...
>    end
>    n = n.next
>  end


traverse_id really is faster, because the internal lookups are much faster than the repeated node.id and node.next calls. But still, it is mostly about style.

Best wishes,
Taco


From pragma at wxs.nl  Sat Nov 10 12:28:41 2012
From: pragma at wxs.nl (Hans Hagen)
Date: Sat, 10 Nov 2012 12:28:41 +0100
Subject: [luatex] Behavior of node lists.
In-Reply-To: <509E32B4.5000600@arcor.de>
References: <4E11668A.8050208@free.fr> <4E14667E.7010201@elvenkind.com>
 <509AAA5F.7090304@arcor.de> <509B6A05.2050708@elvenkind.com>
 <509B8C36.6090506@wxs.nl> <509C2266.2030609@arcor.de>
 <509C2DB0.3080902@wxs.nl> <509D5E0F.2040405@arcor.de>
 <509D6B40.6050705@wxs.nl> <509E32B4.5000600@arcor.de>
Message-ID: <509E3A69.8000902@wxs.nl>

On 11/10/2012 11:55 AM, Stephan Hennig wrote:

> Good point, too.  But let me ask again, the returned nodes are always
> the same as those given as arguments, with changed fields, but they
> never change identity?  That's not clear from the manual.

Sure, why should they change identity? Think of something like this (no 
head checking and such):

here.next = newnode
newnode.prev = here
if here.next then
   here.next.prev = newnode
   newnode.next = here.next
end

why should nodes become different nodes?

(maybe you think that a head node is something special, but it's not, 
it's just a name for the first node in alist)

> The node 'list' terminology is a bit confusing.  These node 'lists' are
> actually trees.  The latter having sub-trees with their own root (head)
> nodes etc.  A list, in contrast, usually has one invariant head node
> (putting aside operations that explicitly change a list head).  Even
> though I guess, for someone with a strong TeX background it is a trivial
> fact, I think the manual should be a bit more explicit about what head
> exactly to use in insert_before/after.

it's not invariant

head = tex.box[0].list

then mess with the list starting with head and in case of pushing 
something in front adapt the head variable and afterwards set:

tex.box[0].list = head

just linked lists (the concept in luatex is not different from other 
programming langauges)

the manual is not a 'tutorial in programming' and 'linked lists'; in 
fact: a programmer should recognize the concept but a tex macro writer 
might be somewhat confused as tex itself because there is talk like "the 
main vertical list" in manuals but on the other hand, once one starts 
messing with that one knows about the stuff (there is no access to the 
list at the tex end apart from some \last.. and \un.. operations and 
maybe un*box and vsplit resemble some messing list)

concerning a tree: indeed it is a tree with some nodes (not only hlist 
etc but also glyphs that are ligatures) being trees themselves

actually, the tex tracing primitives (showbox etc) will show you that 
kind of nesting in the log

Hans

-----------------------------------------------------------------
                                           Hans Hagen | PRAGMA ADE
               Ridderstraat 27 | 8061 GH Hasselt | The Netherlands
     tel: 038 477 53 69 | voip: 087 875 68 74 | www.pragma-ade.com
                                              | www.pragma-pod.nl
-----------------------------------------------------------------

From pragma at wxs.nl  Sat Nov 10 12:29:46 2012
From: pragma at wxs.nl (Hans Hagen)
Date: Sat, 10 Nov 2012 12:29:46 +0100
Subject: [luatex] Behavior of node lists.
In-Reply-To: <509E334F.2000508@arcor.de>
References: <4E11668A.8050208@free.fr> <4E14667E.7010201@elvenkind.com>
 <509AAA5F.7090304@arcor.de> <509B6A05.2050708@elvenkind.com>
 <509D65FB.7040406@arcor.de> <509D713C.8070706@wxs.nl>
 <509E334F.2000508@arcor.de>
Message-ID: <509E3AAA.1070100@wxs.nl>

On 11/10/2012 11:58 AM, Stephan Hennig wrote:
> Am 09.11.2012 22:10, schrieb Hans Hagen:
>> On 11/9/2012 9:22 PM, Stephan Hennig wrote:
>>
>>> That is,
>>>
>>>     node.insert_after(nil, N, x)
>>>
>>> is not a short-cut for inserting after N, but returns x as new head?
>>
>> no, it returns n as head as well as x:
>>
>>     head, current = node.insert_after(nil,current,x)
>>
>> boils down to
>>
>>     head    = current
>>     current = x
>
>
> But this is in contrast to what the manual says.
>
> | If head is initially nil, it will become new.

new == assigned

>
>> so:
>>
>>     head, current = node.insert_after(head,current,x)
>>
>> becomes:
>>
>>     head    = head or current or x
>>     current = x
>
> All valuable additions to the manual ...

it's not a 'how to mess with linked lists, more a reference manual -)

Hans

-----------------------------------------------------------------
                                           Hans Hagen | PRAGMA ADE
               Ridderstraat 27 | 8061 GH Hasselt | The Netherlands
     tel: 038 477 53 69 | voip: 087 875 68 74 | www.pragma-ade.com
                                              | www.pragma-pod.nl
-----------------------------------------------------------------

From mailing_list at arcor.de  Sat Nov 10 11:55:48 2012
From: mailing_list at arcor.de (Stephan Hennig)
Date: Sat, 10 Nov 2012 11:55:48 +0100
Subject: [luatex] Behavior of node lists.
In-Reply-To: <509D6B40.6050705@wxs.nl>
References: <4E11668A.8050208@free.fr> <4E14667E.7010201@elvenkind.com>
 <509AAA5F.7090304@arcor.de> <509B6A05.2050708@elvenkind.com>
 <509B8C36.6090506@wxs.nl> <509C2266.2030609@arcor.de>
 <509C2DB0.3080902@wxs.nl> <509D5E0F.2040405@arcor.de>
 <509D6B40.6050705@wxs.nl>
Message-ID: <509E32B4.5000600@arcor.de>

Am 09.11.2012 21:44, schrieb Hans Hagen:
> On 11/9/2012 8:48 PM, Stephan Hennig wrote:
> 
>> | The return values are the (potentially mutated) head and the node
>> | new, set up to be part of the list (with correct next field).
>>
>> Does that mean, after calling insert_after, head and new can be
>> different nodes that that given as argument to the function?  If only
>> fields in the original nodes are updated, what's the purpose of
>> returning the nodes again?
> 
> after and before have a consistent similar interface so you can make 
> 'generic' functions that get insert_before or insert_after passed, so 
> it's mostly about consistency in interfaces

Good point.  Would be good to have that in the manual.


> the advantage of passing head to insert_after is that when head is nil 
> at the start of whatever you do, you get a head back:

Good point, too.  But let me ask again, the returned nodes are always
the same as those given as arguments, with changed fields, but they
never change identity?  That's not clear from the manual.


>> Second, when inserting nodes into a deeply nested node list, is the head
>> argument to insert_after the head of the current branch (latest hlist or
>> vlist head) or the top-level head of the node list?
> 
> always the head of the 'current' list

This is what I assumed.  Thanks!

The node 'list' terminology is a bit confusing.  These node 'lists' are
actually trees.  The latter having sub-trees with their own root (head)
nodes etc.  A list, in contrast, usually has one invariant head node
(putting aside operations that explicitly change a list head).  Even
though I guess, for someone with a strong TeX background it is a trivial
fact, I think the manual should be a bit more explicit about what head
exactly to use in insert_before/after.

Best regards,
Stephan Hennig


From mailing_list at arcor.de  Sat Nov 10 11:58:23 2012
From: mailing_list at arcor.de (Stephan Hennig)
Date: Sat, 10 Nov 2012 11:58:23 +0100
Subject: [luatex] Behavior of node lists.
In-Reply-To: <509D713C.8070706@wxs.nl>
References: <4E11668A.8050208@free.fr> <4E14667E.7010201@elvenkind.com>
 <509AAA5F.7090304@arcor.de> <509B6A05.2050708@elvenkind.com>
 <509D65FB.7040406@arcor.de> <509D713C.8070706@wxs.nl>
Message-ID: <509E334F.2000508@arcor.de>

Am 09.11.2012 22:10, schrieb Hans Hagen:
> On 11/9/2012 9:22 PM, Stephan Hennig wrote:
> 
>> That is,
>>
>>    node.insert_after(nil, N, x)
>>
>> is not a short-cut for inserting after N, but returns x as new head?
> 
> no, it returns n as head as well as x:
> 
>    head, current = node.insert_after(nil,current,x)
> 
> boils down to
> 
>    head    = current
>    current = x


But this is in contrast to what the manual says.

| If head is initially nil, it will become new.


> so:
> 
>    head, current = node.insert_after(head,current,x)
> 
> becomes:
> 
>    head    = head or current or x
>    current = x

All valuable additions to the manual ...

Best regards,
Stephan Hennig


From mailing_list at arcor.de  Sat Nov 10 17:54:38 2012
From: mailing_list at arcor.de (Stephan Hennig)
Date: Sat, 10 Nov 2012 17:54:38 +0100
Subject: [luatex] Behavior of node lists.
In-Reply-To: <509E3A69.8000902@wxs.nl>
References: <4E11668A.8050208@free.fr> <4E14667E.7010201@elvenkind.com>
 <509AAA5F.7090304@arcor.de> <509B6A05.2050708@elvenkind.com>
 <509B8C36.6090506@wxs.nl> <509C2266.2030609@arcor.de>
 <509C2DB0.3080902@wxs.nl> <509D5E0F.2040405@arcor.de>
 <509D6B40.6050705@wxs.nl> <509E32B4.5000600@arcor.de>
 <509E3A69.8000902@wxs.nl>
Message-ID: <509E86CE.4080302@arcor.de>

Am 10.11.2012 12:28, schrieb Hans Hagen:
> On 11/10/2012 11:55 AM, Stephan Hennig wrote:
> 
>> Good point, too.  But let me ask again, the returned nodes are always
>> the same as those given as arguments, with changed fields, but they
>> never change identity?  That's not clear from the manual.
> 
> Sure, why should they change identity?

I'm not saying they should.  I'm asking, if they do.  As long as a
function doesn't work against its specification, it can do anything.  In
this case, it's the fact that there are return values at all that
triggers doubts about the identity of nodes.  That return values are
provided for the user's convenience and identity of nodes indeed never
changes is not part of the specs, currently.  Full specs, please!


> (maybe you think that a head node is something special, but it's not, 
> it's just a name for the first node in alist)

Thanks, but I'm aware of that.


>> The node 'list' terminology is a bit confusing.  These node 'lists' are
>> actually trees.  The latter having sub-trees with their own root (head)
>> nodes etc.  A list, in contrast, usually has one invariant head node
>> (putting aside operations that explicitly change a list head).  Even
>> though I guess, for someone with a strong TeX background it is a trivial
>> fact, I think the manual should be a bit more explicit about what head
>> exactly to use in insert_before/after.
> 
> it's not invariant
>
> [...]

Please note the text in parenthesis.


> the manual is not a 'tutorial in programming' and 'linked lists'; in 
> fact: a programmer should recognize the concept

Hans, I'm not asking for a tutorial in programming.  In fact, I feel
quite comfortable handling lists and trees.  I'm just asking for full
specs in the manual.


> but a tex macro writer might be somewhat confused as tex itself
> because there is talk like "the main vertical list" in manuals but on
> the other hand, once one starts messing with that one knows about the
> stuff (there is no access to the list at the tex end apart from some
> \last.. and \un.. operations and maybe un*box and vsplit resemble
> some messing list)
> 
> concerning a tree: indeed it is a tree with some nodes (not only hlist 
> etc but also glyphs that are ligatures) being trees themselves
> 
> actually, the tex tracing primitives (showbox etc) will show you that 
> kind of nesting in the log

I know there's a TeX tradition in the term list.  While I'm quite
comfortable handling lists and trees, I'm not that good at interpreting
all TeX semantics of nodes.  That's why I wrote "for someone with a
strong TeX background it is a trivial fact ...".  But since LuaTeX is
about opening-up and provides new means (data structures) to wrench
TeX's innards, I think it should give at least a big picture about what
the data structures are.  My TeX background doesn't allow me to do
intrusive node list manipulations, but I'd like not to need to read the
TeXbook to know how node lists are organised, e.g., they can be nested,
they are a-cyclic (are they?) etc.

In the LuaTeX reference manual, you're completely hiding the fact that
node lists are trees.  That makes me sometimes wonder what head actually
refers to.  Not in the sense that I have no clue.  But in the sense that
the reference manual is ambiguous.

Best regards,
Stephan Hennig


From patrick at gundla.ch  Sat Nov 10 18:33:36 2012
From: patrick at gundla.ch (Patrick Gundlach)
Date: Sat, 10 Nov 2012 18:33:36 +0100
Subject: [luatex] Behavior of node lists.
In-Reply-To: <509E86CE.4080302@arcor.de>
References: <4E11668A.8050208@free.fr> <4E14667E.7010201@elvenkind.com>
 <509AAA5F.7090304@arcor.de> <509B6A05.2050708@elvenkind.com>
 <509B8C36.6090506@wxs.nl> <509C2266.2030609@arcor.de>
 <509C2DB0.3080902@wxs.nl> <509D5E0F.2040405@arcor.de>
 <509D6B40.6050705@wxs.nl> <509E32B4.5000600@arcor.de>
 <509E3A69.8000902@wxs.nl> <509E86CE.4080302@arcor.de>
Message-ID: <A00C3CF0-1A88-48EC-90B0-6D8E6D298281@gundla.ch>

Hello Stephan,

without answering your email, I'd like to mention two things that helped me understand nodelists:

http://wiki.luatex.org/index.php/TeX_without_TeX

and

https://gist.github.com/556247

Patrick



From mailing_list at arcor.de  Sat Nov 10 19:22:24 2012
From: mailing_list at arcor.de (Stephan Hennig)
Date: Sat, 10 Nov 2012 19:22:24 +0100
Subject: [luatex] Behavior of node lists.
In-Reply-To: <509E3AAA.1070100@wxs.nl>
References: <4E11668A.8050208@free.fr> <4E14667E.7010201@elvenkind.com>
 <509AAA5F.7090304@arcor.de> <509B6A05.2050708@elvenkind.com>
 <509D65FB.7040406@arcor.de> <509D713C.8070706@wxs.nl>
 <509E334F.2000508@arcor.de> <509E3AAA.1070100@wxs.nl>
Message-ID: <509E9B60.8050302@arcor.de>

Am 10.11.2012 12:29, schrieb Hans Hagen:
> On 11/10/2012 11:58 AM, Stephan Hennig wrote:
>> Am 09.11.2012 22:10, schrieb Hans Hagen:
>>> On 11/9/2012 9:22 PM, Stephan Hennig wrote:
>>>
>>>> That is,
>>>>
>>>>     node.insert_after(nil, N, x)
>>>>
>>>> is not a short-cut for inserting after N, but returns x as new head?
>>>
>>> no, it returns n as head as well as x:
>>>
>>>     head, current = node.insert_after(nil,current,x)
>>>
>>> boils down to
>>>
>>>     head    = current
>>>     current = x
>>
>>
>> But this is in contrast to what the manual says.
>>
>> | If head is initially nil, it will become new.
> 
> new == assigned

Or 42?  I still think there's a contradiction.  Let's go with abstract
variable names.  Assuming a function

  a, b = f(x,y,z)

Now, I interpret what you said above as

  If x is nil (see above) then a becomes y.

Whereas the LuaTeX manual says

| If head is initially nil, it will become new.

To translate that to our example

  If x is nil, then a becomes z.

Where's my error?


>>>     head, current = node.insert_after(head,current,x)
>>>
>>> becomes:
>>>
>>>     head    = head or current or x
>>>     current = x
>>
>> All valuable additions to the manual ...
> 
> it's not a 'how to mess with linked lists, more a reference manual -)

Hans, do you think a function signature is enough documentation?  What's
in a name?

Best regards,
Stephan Hennig


From zappathustra at free.fr  Sat Nov 10 21:03:48 2012
From: zappathustra at free.fr (Paul Isambert)
Date: Sat, 10 Nov 2012 21:03:48 +0100
Subject: [luatex] Behavior of node lists.
In-Reply-To: <509E9B60.8050302@arcor.de>
References: <4E11668A.8050208@free.fr> <4E14667E.7010201@elvenkind.com>
 <509AAA5F.7090304@arcor.de> <509B6A05.2050708@elvenkind.com>
 <509D65FB.7040406@arcor.de> <509D713C.8070706@wxs.nl>
 <509E334F.2000508@arcor.de> <509E3AAA.1070100@wxs.nl>
 <509E9B60.8050302@arcor.de>
Message-ID: <1352577828.509eb32401a3a@imp.free.fr>

Selon Stephan Hennig <mailing_list at arcor.de>:

> Am 10.11.2012 12:29, schrieb Hans Hagen:
> > On 11/10/2012 11:58 AM, Stephan Hennig wrote:
> >> Am 09.11.2012 22:10, schrieb Hans Hagen:
> >>> On 11/9/2012 9:22 PM, Stephan Hennig wrote:
> >>>
> >>>> That is,
> >>>>
> >>>>     node.insert_after(nil, N, x)
> >>>>
> >>>> is not a short-cut for inserting after N, but returns x as new head?
> >>>
> >>> no, it returns n as head as well as x:
> >>>
> >>>     head, current = node.insert_after(nil,current,x)
> >>>
> >>> boils down to
> >>>
> >>>     head    = current
> >>>     current = x
> >>
> >>
> >> But this is in contrast to what the manual says.
> >>
> >> | If head is initially nil, it will become new.
> >
> > new == assigned
>
> Or 42?  I still think there's a contradiction.  Let's go with abstract
> variable names.  Assuming a function
>
>   a, b = f(x,y,z)
>
> Now, I interpret what you said above as
>
>   If x is nil (see above) then a becomes y.
>
> Whereas the LuaTeX manual says
>
> | If head is initially nil, it will become new.

It's an error in the manual; it makes little sense anyway for "new" to be the
head if you insert AFTER "current" (the description is valid for
"node.insert_before").

> >>>     head, current = node.insert_after(head,current,x)
> >>>
> >>> becomes:
> >>>
> >>>     head    = head or current or x
> >>>     current = x
> >>
> >> All valuable additions to the manual ...
> >
> > it's not a 'how to mess with linked lists, more a reference manual -)
>
> Hans, do you think a function signature is enough documentation?  What's
> in a name?

If you rely on the manual to work with LuaTeX, you'll learn mostly by
experimentation anyway; I've never found the descriptions there confusing
(notwithstanding some errors), though sometimes not very enlightening either,
but I've never expected them to be so. There still room for a "LuaTeX User's
Guide", to be written by anybody.

Best,
Paul



From mtw at view.net.au  Sun Nov 11 08:46:20 2012
From: mtw at view.net.au (Michael Talbot-Wilson)
Date: Sun, 11 Nov 2012 18:16:20 +1030
Subject: [luatex] Putting an image in a box
Message-ID: <Pine.LNX.4.64.1211111749550.31812@calypso.view.net.au>

I'm trying to learn how to use luatex but not getting far.  I guess
for everyone else it's obvious how to do this but I can't see it.

I'd like to read a PDF image file and put it in a TeX box, just like

\pdfximage {myimage.pdf}
\setbox8\hbox{\pdfrefximage \pdflastximage}

But I'd like lua to look up the file name, e.g. assign it to the
variable the_name, then use something like

a = img.new()
a.filename = the_name
n = img.node(a)
tex.setbox(8, n)

But the last triggers an error:

This is LuaTeX, Version beta-0.70.2-2012062812 (TeX Live 2012)
  \write18 enabled.
(./b7904.tex
! LuaTeX error <\directlua >:1: setbox: incompatible node type
(pdf_refximage)

stack traceback:
         [C]: in function 'setbox'
         <\directlua >:1: in main chunk.
l.76 }

Can it be done with pdf.obj instead?

n = pdf.obj("file", the_name)

But all I can see then is pdf.refobj(n) "so the object will be written
out".  I don't want it written out, I want it in box8.

I'd hope that pdf.refobj() could do something like the second pdftex
line above.

Even more I'd hope that obj.setbox() would work with a pdf_refximage
node, just as \hbox{\pdfrefximage \pdflastximage}, if I understand
rightly, as the code seems to say, works with a pdf_refximage.

Given such a node, how do you put it in a box?

Okay, forget nodes.  Given a lua variable containing a PDF filename,
how do you put the contents of that file in a TeX box?

From mailing_list at arcor.de  Mon Nov 12 19:56:42 2012
From: mailing_list at arcor.de (Stephan Hennig)
Date: Mon, 12 Nov 2012 19:56:42 +0100
Subject: [luatex] Behavior of node lists.
In-Reply-To: <A00C3CF0-1A88-48EC-90B0-6D8E6D298281@gundla.ch>
References: <4E11668A.8050208@free.fr> <4E14667E.7010201@elvenkind.com>
 <509AAA5F.7090304@arcor.de> <509B6A05.2050708@elvenkind.com>
 <509B8C36.6090506@wxs.nl> <509C2266.2030609@arcor.de>
 <509C2DB0.3080902@wxs.nl> <509D5E0F.2040405@arcor.de>
 <509D6B40.6050705@wxs.nl> <509E32B4.5000600@arcor.de>
 <509E3A69.8000902@wxs.nl> <509E86CE.4080302@arcor.de>
 <A00C3CF0-1A88-48EC-90B0-6D8E6D298281@gundla.ch>
Message-ID: <50A1466A.7080508@arcor.de>

Am 10.11.2012 18:33, schrieb Patrick Gundlach:

> I'd like to mention two things that helped me understand nodelists:
> 
> http://wiki.luatex.org/index.php/TeX_without_TeX

I knew this, but I really have to have a look at this again if I find
the time.  And these TUGboat articles:

Isambert, Paul; Three things you can do with LuaTeX that would be
extremely painful otherwise; TUGboat, Volume 31 (2010), No. 3,
<URL:http://www.tug.org/TUGboat/tb31-3/tb99isambert.pdf>

Isambert, Paul; LuaTeX: What it takes to make a paragraph; TUGboat,
Volume 32 (2011), No. 1,
<URL:http://www.tug.org/TUGboat/tb32-1/tb100isambert.pdf>


> and
> 
> https://gist.github.com/556247

Yeah, thanks for this code!  I've added yet another comment at GitHub
yesterday.

Best regards,
Stephan Hennig


From mailing_list at arcor.de  Mon Nov 12 19:23:17 2012
From: mailing_list at arcor.de (Stephan Hennig)
Date: Mon, 12 Nov 2012 19:23:17 +0100
Subject: [luatex] Behavior of node lists.
In-Reply-To: <1352577828.509eb32401a3a@imp.free.fr>
References: <4E11668A.8050208@free.fr> <4E14667E.7010201@elvenkind.com>
 <509AAA5F.7090304@arcor.de> <509B6A05.2050708@elvenkind.com>
 <509D65FB.7040406@arcor.de> <509D713C.8070706@wxs.nl>
 <509E334F.2000508@arcor.de> <509E3AAA.1070100@wxs.nl>
 <509E9B60.8050302@arcor.de> <1352577828.509eb32401a3a@imp.free.fr>
Message-ID: <50A13E95.5050604@arcor.de>

Am 10.11.2012 21:03, schrieb Paul Isambert:

> If you rely on the manual to work with LuaTeX, you'll learn mostly by
> experimentation anyway;

True, but the more hard facts available (about the current state), the
better.


> I've never found the descriptions there confusing (notwithstanding 
> some errors), though sometimes not very enlightening either, but
> I've never expected them to be so. There still room for a "LuaTeX
> User's Guide", to be written by anybody.

Well, I expect a reference manual to tersely, but exhaustively explain
what a function does.  In contrast to a user's guide that explains what
a function can be used for.  (I'll prepare a patch.)

Best regards,
Stephan Hennig


From mtw at view.net.au  Thu Nov 15 06:11:23 2012
From: mtw at view.net.au (Michael Talbot-Wilson)
Date: Thu, 15 Nov 2012 15:41:23 +1030
Subject: [luatex] Putting an image in a box
In-Reply-To: <Pine.LNX.4.64.1211111749550.31812@calypso.view.net.au>
References: <Pine.LNX.4.64.1211111749550.31812@calypso.view.net.au>
Message-ID: <Pine.LNX.4.64.1211130922420.2427@calypso.view.net.au>

Let me try again.

On Sun, 11 Nov 2012, Michael Talbot-Wilson wrote:

> a = img.new()
> a.filename = somename
> n = img.node(a)
> tex.setbox(8, n)

(where somename is a Lua string).

I guess the prior question is, can the contents of a PDF file read by
lua be placed in a TeX box?

Or, can a lua string be used with pdftex syntax e.g. as the argument
of \pdfximage?

Or, if not, can image userdata obtained as above be placed in a TeX
box by any other means?

Or, if not, is there any way that luatex can place in a TeX box
content from a file given that the file's name is available only as a
lua string?

It seems that the answer is No, No, No, No.  Hence, silence.

I guess the usual solution is to run LuaTeX twice, have lua write the data
in the first run and \read1 to\somewhere in the second.

Is that what you guys are doing?

It's a pity there's no other way.  There are many situations in which
one wants to include information, e.g. when writing a letter, when you
might want supply a person's name and have TeX get the address from
the database.

And that solution wouldn't be of much use for someone who wanted to
print a stamp catalogue with images and descriptions of 5000 postage
stamps.

I guess what I need to do is use a preprocessor to do the lookups and
write the TeX file.  Some kind of private preprocessor language coming
up, I think, to chew up my.pretex and spit out my.tex and run TeX on
it.  There are better languages than Lua for writing such a
preprocessor.

It would be nice if the LuaTex callbacks were keyed to TeX csnames.
As it is, the documentation (beta 0.70.0) is impenetrable for anyone
who is not a LuaTeX developer.  open_read_file?  What triggers a call
of that?  find_image_file (p. 34)?  What can you write in TeX that
calls that?  What can TeX do with the actual_name returned?  Did it
define a macro accessible to TeX?  Okay, don't say, President's eyes
only, of course.  I'll go away.

From iamtimlee at outlook.com  Sun Nov 18 12:36:26 2012
From: iamtimlee at outlook.com (LeeTim)
Date: Sun, 18 Nov 2012 11:36:26 +0000
Subject: [luatex] A problem in LuaLaTeX
Message-ID: <BAY002-W922AD279D35D4E22B7EFE6A5570@phx.gbl>

Hi:    I am using LuaLaTeX under Windows 7, the version is                       beta-0.70.2-2012080612 (TeX Live 2012/W32TeX)the source file and the results compiled by xelatex and lualatex is in the attachments.I think this is a bug in LuaTeX.  		 	   		  
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://tug.org/pipermail/luatex/attachments/20121118/3c88ba16/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: test.tex
Type: application/x-tex
Size: 8944 bytes
Desc: not available
URL: <http://tug.org/pipermail/luatex/attachments/20121118/3c88ba16/attachment-0001.tex>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: xelatex.PNG
Type: image/png
Size: 19705 bytes
Desc: not available
URL: <http://tug.org/pipermail/luatex/attachments/20121118/3c88ba16/attachment-0002.png>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: lualatex.PNG
Type: image/png
Size: 20053 bytes
Desc: not available
URL: <http://tug.org/pipermail/luatex/attachments/20121118/3c88ba16/attachment-0003.png>

From kakuto at fuk.kindai.ac.jp  Mon Nov 19 15:19:01 2012
From: kakuto at fuk.kindai.ac.jp (Akira Kakuto)
Date: Mon, 19 Nov 2012 23:19:01 +0900
Subject: [luatex]  A problem in LuaLaTeX
Message-ID: <135333474126352400004ef9@sniffer>

> I am using LuaLaTeX under Windows 7, the version is
> beta-0.70.2-2012080612 (TeX Live 2012/W32TeX). The source file and
> the results compiled by xelatex and lualatex is in the attachments.
> I think this is a bug in LuaTeX.

Confirmed on Windows 7.
Strangely I have a correct result on Windows XP.

best regards,
Akira


From kakuto at fuk.kindai.ac.jp  Mon Nov 19 16:02:38 2012
From: kakuto at fuk.kindai.ac.jp (Akira Kakuto)
Date: Tue, 20 Nov 2012 00:02:38 +0900
Subject: [luatex]  A problem in LuaLaTeX
Message-ID: <135333735892415900004f87@sniffer>

>> I am using LuaLaTeX under Windows 7, the version is
>> beta-0.70.2-2012080612 (TeX Live 2012/W32TeX). The source file and
>> the results compiled by xelatex and lualatex is in the attachments.
>> I think this is a bug in LuaTeX.

> Confirmed on Windows 7.
> Strangely I have a correct result on Windows XP.

I've found that LucidaTypewriterRegular.ttf, which seems
not to exist on Windows 7, is used on XP.
If I use LTYPE.TTF instead, I obtain the same buggy result
also on XP.

best regards,
Akira


From Herbert.Voss at FU-Berlin.DE  Mon Nov 19 16:13:10 2012
From: Herbert.Voss at FU-Berlin.DE (Herbert Voss)
Date: Mon, 19 Nov 2012 16:13:10 +0100
Subject: [luatex] A problem in LuaLaTeX
In-Reply-To: <135333735892415900004f87@sniffer>
References: <135333735892415900004f87@sniffer>
Message-ID: <50AA4C86.9050302@FU-Berlin.DE>

Am 19.11.2012 16:02, schrieb Akira Kakuto:
>>> I am using LuaLaTeX under Windows 7, the version is
>>> beta-0.70.2-2012080612 (TeX Live 2012/W32TeX). The source file and
>>> the results compiled by xelatex and lualatex is in the attachments.
>>> I think this is a bug in LuaTeX.
>
>> Confirmed on Windows 7.
>> Strangely I have a correct result on Windows XP.
>
> I've found that LucidaTypewriterRegular.ttf, which seems
> not to exist on Windows 7, is used on XP.
> If I use LTYPE.TTF instead, I obtain the same buggy result
> also on XP.

with \newfontfamily\lucidasanstypewriter{LinMonoO}

(the Mono font from Libertine)

it is ok. With DejaVu Sans Mono not (Linux/TeXLive)

Herbert


From dirk.laurie at gmail.com  Mon Nov 19 16:48:44 2012
From: dirk.laurie at gmail.com (Dirk Laurie)
Date: Mon, 19 Nov 2012 17:48:44 +0200
Subject: [luatex] A problem in LuaLaTeX
In-Reply-To: <BAY002-W922AD279D35D4E22B7EFE6A5570@phx.gbl>
References: <BAY002-W922AD279D35D4E22B7EFE6A5570@phx.gbl>
Message-ID: <CABcj=tnW-qLRaVjv6_t_PUQ4-iBQy+YZtmi6mb4Z=GPxs4=QtQ@mail.gmail.com>

2012/11/18 LeeTim <iamtimlee at outlook.com>:

>     I am using LuaLaTeX under Windows 7, the version is
>                       beta-0.70.2-2012080612 (TeX Live 2012/W32TeX)
> the source file and the results compiled by xelatex and lualatex is in the
> attachments.
> I think this is a bug in LuaTeX.

I'm using TeXLive on Linux.  I've got the Lucida fonts on my
XP partition.  I convert them to be used with TeX by the following
script:
FONTDIR=~/.texmf-var/fonts/truetype
# Assume Lucida ttf files already in fontdir
texhash
for i in \
    "BrightDemiBold.ttf lbd" \
    "BrightDemiItalic.ttf lbdi" \
    "BrightItalic.ttf lbi" \
    "BrightRegular.ttf lbr" \
    "SansDemiBold.ttf lsd" \
    "SansRegular.ttf lsr" \
    "TypewriterBold.ttf lbtb" \
    "TypewriterRegular.ttf lbtr" \
    ; do otftotfm -ae T1-WGL4.enc $FONTDIR/Lucida$i ; done

There are many, many messages like

I had to round some heights by 15.1366997 units.
I had to round some depths by 0.9766006 units.
I had to round some italic corrections by 0.7323999 units.

So obviously there are precision issues.

I then try test.tex. It says I don't have Lucida Grande, which is true.
Wikipedia says Lucida Sans is almost exactly the same. I change
text.tex to use Lucida Sans instead. The PDF file looks perfect.

So I think there is a problem with your font files, not with luatex.

From taco at elvenkind.com  Mon Nov 19 17:02:38 2012
From: taco at elvenkind.com (Taco Hoekwater)
Date: Mon, 19 Nov 2012 17:02:38 +0100
Subject: [luatex] A problem in LuaLaTeX
In-Reply-To: <CABcj=tnW-qLRaVjv6_t_PUQ4-iBQy+YZtmi6mb4Z=GPxs4=QtQ@mail.gmail.com>
References: <BAY002-W922AD279D35D4E22B7EFE6A5570@phx.gbl>
 <CABcj=tnW-qLRaVjv6_t_PUQ4-iBQy+YZtmi6mb4Z=GPxs4=QtQ@mail.gmail.com>
Message-ID: <50AA581E.9080107@elvenkind.com>

On 11/19/2012 04:48 PM, Dirk Laurie wrote:
>
> So I think there is a problem with your font files, not with luatex.

That would be my guess as well, also looking at Akira's results.

Best wishes,
Taco



From kiryen at gmail.com  Tue Nov 20 00:56:29 2012
From: kiryen at gmail.com (Andy Lin)
Date: Mon, 19 Nov 2012 18:56:29 -0500
Subject: [luatex] A problem in LuaLaTeX
In-Reply-To: <50AA581E.9080107@elvenkind.com>
References: <BAY002-W922AD279D35D4E22B7EFE6A5570@phx.gbl>
 <CABcj=tnW-qLRaVjv6_t_PUQ4-iBQy+YZtmi6mb4Z=GPxs4=QtQ@mail.gmail.com>
 <50AA581E.9080107@elvenkind.com>
Message-ID: <CADvAzUS=cTuCFWS_sr6aBKYrGw4C2z-r4NMf3BeQJUnVkropEg@mail.gmail.com>

Um, Lucida Sans Typewriter is a monospaced font, is it not? Therefore,
isn't it LuaLaTeX that is producing the correct output? (
http://tug.org/pipermail/xetex/2010-September/018524.html)

-Andy


On Mon, Nov 19, 2012 at 11:02 AM, Taco Hoekwater <taco at elvenkind.com> wrote:

> On 11/19/2012 04:48 PM, Dirk Laurie wrote:
>
>>
>> So I think there is a problem with your font files, not with luatex.
>>
>
> That would be my guess as well, also looking at Akira's results.
>
> Best wishes,
> Taco
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://tug.org/pipermail/luatex/attachments/20121119/2d0c35a5/attachment.html>

From slade at jnanam.net  Tue Nov 20 01:31:38 2012
From: slade at jnanam.net (Benjamin Slade)
Date: Mon, 19 Nov 2012 18:31:38 -0600
Subject: [luatex] luatex misalignment of certain diacritics in certain LaTeX
	environments
Message-ID: <87ehjpru6t.fsf@jnanam.net>

I've noticed that certain diacritics---including over-dots, under-rings,
but not acute accents or macrons---are misaligned by the luatex engine
when they occur in tabular or hbox environments (and also in the
linguistics example/glossing packages linguex and expex). When compiled
with xetex, these misalignments do not occur.

 Is this a known issue?

 I include a (fairly)
minimal illustrative example below. (Compare alignment of over-dot and
under-ring in source and in luatex vs xetex outputs.)

+----------begin example----------------+

%%% Local Variables: 
%%% TeX-engine: luatex
%%% End: 

\documentclass{article}[12pt]

\usepackage{fontspec}

\setmainfont{Linux Libertine}
\setsansfont[Scale=MatchLowercase]{Linux Biolinum}
\setmonofont{linlibertinem}

\usepackage{expex}
\usepackage{linguex}

\begin{document}

\noindent \underline{Not misaligned in normal environment}\footnote{Except something funny is happening w/ the mono/typewriter text, but perhaps that's a font-specific issue}\\

?sy?m? m?dhun? mr?tam?

\textit{?sy?m? m?dhun? mr?tam?}

\textbf{?sy?m? m?dhun? mr?tam?}

\textsc{?sy?m? m?dhun? mr?tam?}

\textsf{?sy?m? m?dhun? mr?tam?}

\texttt{?sy?m?? m?dhun? mr?tam?}\\


\underline{linguex:}\\
\exg. ?sy?m?? m?dhun? mr?tam?\\
 mouth.\textsc{neu.nom.sg} honey.\textsc{instr} dead.\textsc{neu.nom.sg}\\
\trans ``the mouth, killed with honey''

\noindent \underline{Misaligned in Tabular:}\\
\begin{tabular}{lll}
  misaligned & mr?tam? & ?sy?m?? \\
\end{tabular}
\vspace{12pt}

\noindent \underline{Misaligned in hbox:}\\
\hbox{mr?tam? ?sy?m??}


% \underline{expex:}\\
% \ex
% \begingl
% \gla ?sy?m? m?dhun? mr?tam?//
% \glb mouth.\textsc{neu.nom.sg} honey.\textsc{instr} dead.\textsc{neu.nom.sg}//
% \glft ``the mouth, killed with honey''//
% \endgl
% \xe

\end{document}

+----------end example-----------------+

-- 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
pgp fingerprint: 21BA 2AE1 28F6 DF36 110A 0E9C A320 BBE8 2B52 EE19
{sent by mu4e on Emacs running under GNU/Linux}

From slade at jnanam.net  Tue Nov 20 14:23:01 2012
From: slade at jnanam.net (Benjamin Slade)
Date: Tue, 20 Nov 2012 07:23:01 -0600
Subject: [luatex] luatex misalignment of certain diacritics in certain
	LaTeX environments
Message-ID: <876250s91m.fsf@jnanam.net>

I just noticed that the Unicode characters didn't come through properly.

Here it is at Pastebin: http://pastebin.com/FWaPv4JT

Original message:
-----------------
I've noticed that certain diacritics---including over-dots, under-rings,
but not acute accents or macrons---are misaligned by the luatex engine
when they occur in tabular or hbox environments (and also in the
linguistics example/glossing packages linguex and expex). When compiled
with xetex, these misalignments do not occur.

 Is this a known issue?

 I include a (fairly)
minimal illustrative example below. (Compare alignment of over-dot and
under-ring in source and in luatex vs xetex outputs.)
-- 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
pgp fingerprint: 21BA 2AE1 28F6 DF36 110A 0E9C A320 BBE8 2B52 EE19
{sent by mu4e on Emacs running under GNU/Linux}

From mojca.miklavec.lists at gmail.com  Fri Nov 23 09:38:35 2012
From: mojca.miklavec.lists at gmail.com (Mojca Miklavec)
Date: Fri, 23 Nov 2012 09:38:35 +0100
Subject: [luatex] luatex misalignment of certain diacritics in certain
 LaTeX environments
In-Reply-To: <87ehjpru6t.fsf@jnanam.net>
References: <87ehjpru6t.fsf@jnanam.net>
Message-ID: <CALBOmsbBPokZSqc=Boe7=MV4wP0y2A8=yMJjpJOD5tc3KAF3hg@mail.gmail.com>

On Tue, Nov 20, 2012 at 1:31 AM, Benjamin Slade wrote:
> I've noticed that certain diacritics---including over-dots, under-rings,
> but not acute accents or macrons---are misaligned by the luatex engine
> when they occur in tabular or hbox environments (and also in the
> linguistics example/glossing packages linguex and expex). When compiled
> with xetex, these misalignments do not occur.
>
>  Is this a known issue?

See http://tracker.luatex.org/view.php?id=651.

LaTeX code for font handling in LuaTeX was derived from ConTeXt, so I
wouldn't be surprised to see the same problem there. On top of that
the maintainer left, so the code hasn't been updated in a while.

First of all, I remember being told that I had to use
    \definefontfeature[default][default][mode=node,mark=yes,mkmk=yes]
if I wanted the accents to be positioned properly in the first place.
Provided that the font has that feature in the first place. The
features mark and mkmk should be enabled by default in LuaLaTeX
(MarkToMark and MarkToBase), but I'm not sure how to switch to a
"node" mode in case that implementation of that part is the same as in
ConTeXt.

But even after that, there was a bug that mispositioned accents inside
\hbox as you can see on the tracker. That problem was fixed in
ConTeXt, but I still need to compare the output of your latex file
with ConTeXt.

A quick ConTeXt variant to test (the same structure that I had
problems with a year and a half ago) would be the following:

\definefontfeature[default][default][mode=node,mark=yes,mkmk=yes]
\definefontsynonym[a][file:LinLibertine_R.otf][features=default]

\starttext
\definedfont[a]a\hbox to 1cm{}\hbox to 5cm{mr?ta? ?sy???}a
\stoptext

Does that come out OK for you? (LuaTeX and XeTeX output look the same
to me, but I don't know what to expect.)

Mojca

>  I include a (fairly)
> minimal illustrative example below. (Compare alignment of over-dot and
> under-ring in source and in luatex vs xetex outputs.)
>
> +----------begin example----------------+
>
> %%% Local Variables:
> %%% TeX-engine: luatex
> %%% End:
>
> \documentclass{article}[12pt]
>
> \usepackage{fontspec}
>
> \setmainfont{Linux Libertine}
> \setsansfont[Scale=MatchLowercase]{Linux Biolinum}
> \setmonofont{linlibertinem}
>
> \usepackage{expex}
> \usepackage{linguex}
>
> \begin{document}
>
> \noindent \underline{Not misaligned in normal environment}\footnote{Except something funny is happening w/ the mono/typewriter text, but perhaps that's a font-specific issue}\\
>
> ?sy?m? m?dhun? mr?tam?
>
> \textit{?sy?m? m?dhun? mr?tam?}
>
> \textbf{?sy?m? m?dhun? mr?tam?}
>
> \textsc{?sy?m? m?dhun? mr?tam?}
>
> \textsf{?sy?m? m?dhun? mr?tam?}
>
> \texttt{?sy?m?? m?dhun? mr?tam?}\\
>
>
> \underline{linguex:}\\
> \exg. ?sy?m?? m?dhun? mr?tam?\\
>  mouth.\textsc{neu.nom.sg} honey.\textsc{instr} dead.\textsc{neu.nom.sg}\\
> \trans ``the mouth, killed with honey''
>
> \noindent \underline{Misaligned in Tabular:}\\
> \begin{tabular}{lll}
>   misaligned & mr?tam? & ?sy?m?? \\
> \end{tabular}
> \vspace{12pt}
>
> \noindent \underline{Misaligned in hbox:}\\
> \hbox{mr?tam? ?sy?m??}
>
>
> % \underline{expex:}\\
> % \ex
> % \begingl
> % \gla ?sy?m? m?dhun? mr?tam?//
> % \glb mouth.\textsc{neu.nom.sg} honey.\textsc{instr} dead.\textsc{neu.nom.sg}//
> % \glft ``the mouth, killed with honey''//
> % \endgl
> % \xe
>
> \end{document}
>
> +----------end example-----------------+


From hajtmar at gyza.cz  Sun Nov 25 19:55:20 2012
From: hajtmar at gyza.cz (Jaroslav Hajtmar)
Date: Sun, 25 Nov 2012 19:55:20 +0100
Subject: [luatex] LuaTeX and classical 8-bit fonts...
Message-ID: <50B26998.9060804@gyza.cz>

Hello LuaTeXist.
I have maybe non traditional question:
Is it possible to convince LuaTEX, so that the input encoding it is 
UTF8, but inside worked according to the selected encoding with classic 
8-bit fonts?
It is LuaTEX able to work with a classic 8-bit fonts?
To explain: I am looking for possibilities to compile CsPlainTeX sources 
(used Czech format).
by LuaTEX.

Thanks Jaroslav Hajtmar

From Philipp.Gesang at alumni.uni-heidelberg.de  Tue Nov 27 13:30:20 2012
From: Philipp.Gesang at alumni.uni-heidelberg.de (Philipp Gesang)
Date: Tue, 27 Nov 2012 13:30:20 +0100
Subject: [luatex] [reference] description of tex.badness(t,s)
Message-ID: <20121127123020.GA4608@phlegethon.router_intern>

Hi all,

the description of tex.badness does not appear to be entirely
right: the first argument is repeatedly referred to as ?f? as
well as ?t? (as in arithmetic.w).

Regards
Philipp


-------------- next part --------------
--- luatexref-t.tex.orig	2012-11-27 13:23:42.529564539 +0100
+++ luatexref-t.tex	2012-11-27 13:25:11.898774431 +0100
@@ -6933,12 +6933,12 @@
 \subsubsection{\luatex{tex.badness} (0.53)}
 
 \startfunctioncall
-<number> b = tex.badness(<number> f, <number> s)
+<number> b = tex.badness(<number> t, <number> s)
 \stopfunctioncall
 
 This helper function is useful
-during linebreak calculations. \type{f} and \type{s} are scaled values; the function
-returns the badness for when total \type{f} is supposed to be made from amounts
+during linebreak calculations. \type{t} and \type{s} are scaled values; the function
+returns the badness for when total \type{t} is supposed to be made from amounts
 that sum to \type{s}.  The returned number is a reasonable approximation of $100(t/s)^3$;
 
 \subsubsection{\luatex{tex.linebreak} (0.53)}
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 198 bytes
Desc: not available
URL: <http://tug.org/pipermail/luatex/attachments/20121127/afb1a2c8/attachment.bin>

From taco at elvenkind.com  Tue Nov 27 15:56:23 2012
From: taco at elvenkind.com (Taco Hoekwater)
Date: Tue, 27 Nov 2012 15:56:23 +0100
Subject: [luatex] [reference] description of tex.badness(t,s)
In-Reply-To: <20121127123020.GA4608@phlegethon.router_intern>
References: <20121127123020.GA4608@phlegethon.router_intern>
Message-ID: <50B4D497.4040007@elvenkind.com>

On 11/27/2012 01:30 PM, Philipp Gesang wrote:
> Hi all,
>
> the description of tex.badness does not appear to be entirely
> right: the first argument is repeatedly referred to as ?f? as
> well as ?t? (as in arithmetic.w).

Thanks, applied


From Herbert.Voss at FU-Berlin.DE  Wed Nov 28 12:19:46 2012
From: Herbert.Voss at FU-Berlin.DE (Herbert Voss)
Date: Wed, 28 Nov 2012 12:19:46 +0100
Subject: [luatex] node list
Message-ID: <50B5F352.6030805@FU-Berlin.DE>

Hi,
I am playing with nodes and callbacks to understand how it works.

\directlua{
function checknode(head)
while head do
  if head.id==37 then
   if head.char==string.byte("c") then
    n=node.new(37)
    n.char=string.byte("d")
    n.font=1
    head=node.insert_after(head,head,n)
   end
  end
  if head.id==0 or head.id==1 then checknode(head.list) end
  head=head.next
end
return true
end
callback.register("post_linebreak_filter",checknode,"checknode")}

abc1
\bye

I tried to test "node.insert_after()" instead of using the next and prev
fields. Is it the correct way to use

    head=node.insert_after(head,head,n)

if I want to insert the new glyph node bwtween existing nodes?
And am i right, that the prev field from node n is missing, but
doesn't hurt in this case? I know, that I can set it.

Herbert

From zappathustra at free.fr  Wed Nov 28 19:44:05 2012
From: zappathustra at free.fr (Paul Isambert)
Date: Wed, 28 Nov 2012 19:44:05 +0100
Subject: [luatex] node list
In-Reply-To: <50B5F352.6030805@FU-Berlin.DE>
References: <50B5F352.6030805@FU-Berlin.DE>
Message-ID: <20121128184406.86055D48092@smtp5-g21.free.fr>

Herbert Voss <Herbert.Voss at fu-berlin.de> a ?crit:
> Hi,
> I am playing with nodes and callbacks to understand how it works.
> 
> \directlua{
> function checknode(head)
> while head do
>   if head.id==37 then
>    if head.char==string.byte("c") then
>     n=node.new(37)
>     n.char=string.byte("d")
>     n.font=1
>     head=node.insert_after(head,head,n)
>    end
>   end
>   if head.id==0 or head.id==1 then checknode(head.list) end
>   head=head.next
> end
> return true
> end
> callback.register("post_linebreak_filter",checknode,"checknode")}

callback.register takes only two arguments.

> abc1
> \bye
> 
> I tried to test "node.insert_after()" instead of using the next and prev
> fields. Is it the correct way to use
> 
>     head=node.insert_after(head,head,n)
> 
> if I want to insert the new glyph node bwtween existing nodes?

More clearly:
  
  head = node.insert_after(a, b, c)

to insert c after b in the list whose head is a (actually any node in
that list).

> And am i right, that the prev field from node n is missing, but
> doesn't hurt in this case? I know, that I can set it.

Actually it IS set (try "print(n.prev)"), and I'm surprised myself,
because I thought ``natural'' nodelists (created by TeX) didn't set the
prev field of their nodes, but actually they're all set. (I thought that
because node.slide() is said to set those prev fields, so I concluded
that by default they aren't.)

But anyway it wouldn't hurt, at least on the TeX side (I don't know any
internal mechanism that needs prev to be set, but I might very well be
wrong).

Best,
Paul


From Herbert.Voss at FU-Berlin.DE  Wed Nov 28 20:35:13 2012
From: Herbert.Voss at FU-Berlin.DE (Herbert Voss)
Date: Wed, 28 Nov 2012 20:35:13 +0100
Subject: [luatex] node list
In-Reply-To: <20121128184406.86055D48092@smtp5-g21.free.fr>
References: <50B5F352.6030805@FU-Berlin.DE>
 <20121128184406.86055D48092@smtp5-g21.free.fr>
Message-ID: <50B66771.6010200@FU-Berlin.DE>

Am 28.11.2012 19:44, schrieb Paul Isambert:

>> callback.register("post_linebreak_filter",checknode,"checknode")}
>
> callback.register takes only two arguments.

yes, my fault. I copied the code from my LuaLaTeX source with the
function luatexbase.add_to_callback

>>      head=node.insert_after(head,head,n)
>>
>> if I want to insert the new glyph node bwtween existing nodes?
>
> More clearly:
>
>    head = node.insert_after(a, b, c)
>
> to insert c after b in the list whose head is a (actually any node in
> that list).

 From what is written in the manual I thought that

head=node.insert_after(nil,head,n)

should also work, but it didn't.

>> And am i right, that the prev field from node n is missing, but
>> doesn't hurt in this case? I know, that I can set it.
>
> Actually it IS set (try "print(n.prev)"), and I'm surprised myself,

Me too, because the manual say that it is not set.

Herbert




From zappathustra at free.fr  Wed Nov 28 20:50:57 2012
From: zappathustra at free.fr (Paul Isambert)
Date: Wed, 28 Nov 2012 20:50:57 +0100
Subject: [luatex] node list
In-Reply-To: <50B66771.6010200@FU-Berlin.DE>
References: <50B5F352.6030805@FU-Berlin.DE>
 <20121128184406.86055D48092@smtp5-g21.free.fr>
 <50B66771.6010200@FU-Berlin.DE>
Message-ID: <20121128195058.D2819D48065@smtp5-g21.free.fr>

Herbert Voss <Herbert.Voss at fu-berlin.de> a ?crit:
> Am 28.11.2012 19:44, schrieb Paul Isambert:
> >    head = node.insert_after(a, b, c)
> >
> > to insert c after b in the list whose head is a (actually any node in
> > that list).
> 
>  From what is written in the manual I thought that
> 
> head=node.insert_after(nil,head,n)
> 
> should also work, but it didn't.

It should, if "head" is non-nil. So I'm surprised, again, that it
doesn't.

> >> And am i right, that the prev field from node n is missing, but
> >> doesn't hurt in this case? I know, that I can set it.
> >
> > Actually it IS set (try "print(n.prev)"), and I'm surprised myself,
> 
> Me too, because the manual say that it is not set.

Taco? :)

Best,
Paul


From Herbert.Voss at FU-Berlin.DE  Thu Nov 29 10:36:21 2012
From: Herbert.Voss at FU-Berlin.DE (Herbert Voss)
Date: Thu, 29 Nov 2012 10:36:21 +0100
Subject: [luatex] node.traverse
Message-ID: <50B72C95.6030608@FU-Berlin.DE>

Hi all,

am I right that I cannot use node.traverse_id for node _trees_
like the following one?

\directlua{function checknode(head)
for t in node.traverse(head) do
  if t.id==0 or t.id==1 then checknode(t.list) end
  if t.id==37 then
   if t.char>96 and t.char<122 then t.char=t.char-32 end
  end
end
return true
end
callback.register("post_linebreak_filter",checknode)}

abc2112\par And so on \dots %% converting into uppercase

\bye

traverse and traverse_id work only on lists, right?

And next question: should one use t.head instead of t.list.
I read that the name list changes to head, but I can't find
the documentation where I read it.

Herbert

From zappathustra at free.fr  Thu Nov 29 10:47:31 2012
From: zappathustra at free.fr (Paul Isambert)
Date: Thu, 29 Nov 2012 10:47:31 +0100
Subject: [luatex] node.traverse
In-Reply-To: <50B72C95.6030608@FU-Berlin.DE>
References: <50B72C95.6030608@FU-Berlin.DE>
Message-ID: <1354182451.50b72f3323bdc@imp.free.fr>

Selon Herbert Voss <Herbert.Voss at fu-berlin.de>:

> Hi all,
>
> am I right that I cannot use node.traverse_id for node _trees_
> like the following one?
>
> \directlua{function checknode(head)
> for t in node.traverse(head) do
>   if t.id==0 or t.id==1 then checknode(t.list) end
>   if t.id==37 then
>    if t.char>96 and t.char<122 then t.char=t.char-32 end
>   end
> end
> return true
> end
> callback.register("post_linebreak_filter",checknode)}
>
> abc2112\par And so on \dots %% converting into uppercase
>
> \bye
>
> traverse and traverse_id work only on lists, right?

I'm not sure I understand the point, but indeed traverse(_id) browses the nodes
of a list; if one of those nodes is a v/hlist, then you have to call the
function recursively on its head (it isn't done automatically, if that's what
you're asking).

> And next question: should one use t.head instead of t.list.
> I read that the name list changes to head, but I can't find
> the documentation where I read it.

You should use "head", because "list" is more or less deprecated, but for the
moment they're equivalent (I *think* "list" will disappear in v.0.80).

Best,
Paul

From petr at olsak.net  Wed Nov 28 21:03:27 2012
From: petr at olsak.net (Petr Olsak)
Date: Wed, 28 Nov 2012 21:03:27 +0100
Subject: [luatex] \font primitive does not read otf file
Message-ID: <alpine.LNX.2.00.1211282049390.25434@newton.feld.cvut.cz>


Hello,

I am starting with LuaTeX and I have problem to find the relevant 
documentation about \font primitive. There is only one document

    http://www.luatex.org/talks/print-plain-tug-2009.pdf

page 7. It seems that the \font primitive works like in XeTeX. Thus I 
started with experiments:

    luatex -ini luatex.ini
    This is LuaTeX, Version beta-0.70.2-2012052410 (TeX Live 2012) (INITEX)
    (/usr/share/texmf-dist/tex/plain/config/luatex.ini
    (/usr/share/texmf/tex/generic/config/luatexiniconfig.tex)
    (/usr/share/texmf/tex/generic/config/luatex-unicode-letters.tex
    ...
    Beginning to dump on file luatex.fmt
    (format=luatex 2012.11.28)
    3439 strings using 12961 bytes
    ...
    No pages of output.
    Transcript written on luatex.log.

OK, the format luatex.fmt is generated. Then I prepared the following 
document pok.tex:

\font\aa="[lmroman10-regular]"
\aa  text
\end

Now, I run:

    luatex -fmt luatex pok
    This is LuaTeX, Version beta-0.70.2-2012052410 (TeX Live 2012)
    (./pok.tex
    ! Font \aa=[lmroman10-regular] not loadable: metric data not found or bad.
    <to be read again>
                       \aa
    l.2 \aa
             text
    ?

kpsewhich lmroman10-regular.otf says:

    /usr/share/texmf-dist/fonts/opentype/public/lm/lmroman10-regular.otf

The same experiment with XeTeX passes without problems.

What is wrong?

Thanks

Petr Olsak

From taco at elvenkind.com  Fri Nov 30 09:04:37 2012
From: taco at elvenkind.com (Taco Hoekwater)
Date: Fri, 30 Nov 2012 09:04:37 +0100
Subject: [luatex] node list
In-Reply-To: <20121128184406.86055D48092@smtp5-g21.free.fr>
References: <50B5F352.6030805@FU-Berlin.DE>
 <20121128184406.86055D48092@smtp5-g21.free.fr>
Message-ID: <50B86895.9070501@elvenkind.com>

On 11/28/2012 07:44 PM, Paul Isambert wrote:
>
> Actually it IS set (try "print(n.prev)"), and I'm surprised myself,
> because I thought ``natural'' nodelists (created by TeX) didn't set the
> prev field of their nodes, but actually they're all set. (I thought that
> because node.slide() is said to set those prev fields, so I concluded
> that by default they aren't.)

prev nodes are normally set automatically by the internal functions,
but sometimes while building a list 'by hand' it is a bit impractical
to set them right away. That is why node.slide() exists.

(and it also made a useful debugging tool for the internals when
prev fields were still new).

Best wishes,
Taco

From taco at elvenkind.com  Fri Nov 30 09:11:46 2012
From: taco at elvenkind.com (Taco Hoekwater)
Date: Fri, 30 Nov 2012 09:11:46 +0100
Subject: [luatex] node list
In-Reply-To: <20121128195058.D2819D48065@smtp5-g21.free.fr>
References: <50B5F352.6030805@FU-Berlin.DE>
 <20121128184406.86055D48092@smtp5-g21.free.fr>
 <50B66771.6010200@FU-Berlin.DE>
 <20121128195058.D2819D48065@smtp5-g21.free.fr>
Message-ID: <50B86A42.8020006@elvenkind.com>

On 11/28/2012 08:50 PM, Paul Isambert wrote:
> Herbert Voss <Herbert.Voss at fu-berlin.de> a ?crit:
>> Am 28.11.2012 19:44, schrieb Paul Isambert:
>>>     head = node.insert_after(a, b, c)
>>>
>>> to insert c after b in the list whose head is a (actually any node in
>>> that list).
>>
>>   From what is written in the manual I thought that
>>
>> head=node.insert_after(nil,head,n)
>>
>> should also work, but it didn't.
>
> It should, if "head" is non-nil. So I'm surprised, again, that it
> doesn't.

The manual says:

   [ head, new = node.insert_after(head, current, new) ]
   ...
   The return values are the 'head' and the node 'new'
   ...
   If 'head' is initially 'nil'. it will become 'new'.

which indicates to me that it does not work, as otherwise 'head'
would become be more likely to become 'current'. I don't mind
changing that, though. (it looks like both manual entry and
code were copied from insert_before originally).

Best wishes,
Taco

From luatex at nililand.de  Fri Nov 30 11:52:22 2012
From: luatex at nililand.de (Ulrike Fischer)
Date: Fri, 30 Nov 2012 11:52:22 +0100
Subject: [luatex] \font primitive does not read otf file
References: <alpine.LNX.2.00.1211282049390.25434@newton.feld.cvut.cz>
Message-ID: <1vc5qxq7ik9f9.dlg@nililand.de>

Am Wed, 28 Nov 2012 21:03:27 +0100 schrieb Petr Olsak:

> Hello,
> 
> I am starting with LuaTeX and I have problem to find the relevant 
> documentation about \font primitive. There is only one document
> 
>     http://www.luatex.org/talks/print-plain-tug-2009.pdf
> 
> page 7. It seems that the \font primitive works like in XeTeX. 

No, \font works more or less like in pdftex. But there is a
"callback" where you can insert lua-code (a "font-loader") to expand
its capabilities.

One existing font loader is luaotfload so try this:

\input luaotfload.sty
\font\aa="[lmroman10-regular]"
\aa  text
\bye


-- 
Ulrike Fischer 
http://www.troubleshooting-tex.de/


